# 4장 커넥션 관리

HTTP가 어떻게 TCP 커넥션을 사용하는지 다룬다.

---

## 4.1 TCP 커넥션

모든 HTTP 통신은 TCP/IP를 통해 이루어진다.

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- TCP 커넥션이 맺어지면 클라이언트와 서버 간 주고받는 메시지는 손실, 손상, 순서 뒤바뀜 없이 안전하게 전달된다.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 데이터 스트림을 세그먼트 단위로 잘게 나눈 다음 IP 패킷에 담아 전달한다.
- 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달된다.

### 4.1.3 TCP 커넥션 유지하기

- TCP 커넥션은 네 가지 값으로 식별된다: `<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>`
- 서로 다른 두 개의 커넥션은 네 가지 값이 모두 같을 수 없다(일부는 가능).

### 4.1.4 TCP 소켓 프로그래밍

- 소켓 API는 HTTP 프로그래머에게 TCP/IP 세부사항을 숨긴다.
- 소켓 API를 사용하면 TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 연결하여 데이터 스트림을 읽고 쓸 수 있다.

---

## 4.2 TCP의 성능에 대한 고려

HTTP는 TCP 바로 위 계층이기 때문에 HTTP 트랜잭션의 성능은 TCP 성능에 영향을 받는다.

### 4.2.1 HTTP 트랜잭션 지연

- 클라이언트나 서버가 너무 많은 데이터를 내려받거나 복잡한 동적 자원을 실행하지 않는 한, 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
- 주요 지연 요소:
  - DNS 이름 분석을 통한 IP 주소 변환
  - TCP 커넥션 설정
  - 요청 메시지 전송
  - 서버의 요청 처리
  - 응답 메시지 전송

### 4.2.2 성능 관련 중요 요소

- TCP 커넥션 핸드셰이크 설정
- 인터넷 혼잡 제어를 위한 TCP의 느린 시작(slow start)
- 데이터 집약을 위한 네이글(Nagle) 알고리즘
- TCP의 편승(piggyback) 확인응답을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

새 TCP 커넥션을 열 때 연속적인 IP 패킷 교환이 필요하다:
1. 클라이언트 → 서버: 새 TCP 커넥션 생성 요청 (SYN 플래그 포함)
2. 서버 → 클라이언트: 커넥션 요청이 받아들여졌음을 알림 (SYN+ACK)
3. 클라이언트 → 서버: 커넥션이 잘 맺어졌음을 알림 (ACK, 이때 HTTP 요청 메시지도 함께 전송 가능)

- 작은 크기의 데이터 전송에 커넥션이 사용된다면 이런 패킷 교환이 HTTP 성능을 크게 저하시킬 수 있다.
- TCP의 ACK 패킷은 HTTP 요청 메시지 전체를 전달할 수 있을 만큼 큰 경우가 많아, 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다.

### 4.2.4 확인응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지 않기 때문에, TCP는 자체적인 확인 체계를 가진다.
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다.
- 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환한다.

### 4.2.5 TCP 느린 시작(slow start)

- TCP 커넥션은 시간이 지나면서 점차 데이터 전송 속도 제한을 풀어간다(TCP 커넥션 튜닝).
- 생성 초기에는 속도 제한을 크게 두어 부하와 혼잡을 방지한다.
- TCP 느린 시작은 TCP가 한번에 전송할 수 있는 패킷 수를 제한하고, 패킷이 성공적으로 전달되면 송신자는 추가로 더 많은 패킷을 전송할 수 있는 권한을 얻는다(혼잡 윈도 확장).
- 처음 맺어졌을 때 속도가 가장 느리다.

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- TCP 세그먼트 내의 데이터 스트림은 어떤 크기든 전송 가능하다.
- 그러나 TCP 세그먼트의 헤더와 플래그가 40바이트 정도이기 때문에, 작은 데이터를 포함한 많은 수의 TCP 세그먼트 전송은 비효율적이다.
- 네이글 알고리즘은 TCP 세그먼트가 최대 크기가 되지 않으면 전송하지 않는다.
- 다른 모든 패킷이 확인응답을 받았을 경우에만 최대 크기보다 작은 패킷을 전송한다.
- 확인응답 지연 알고리즘과 같이 사용 시 성능이 많이 감소한다.
- HTTP 애플리케이션은 성능 향상을 위해 TCP_NODELAY 파라미터를 설정하여 네이글 알고리즘을 비활성화하기도 한다.

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TCP 커넥션을 끊으면 커넥션 IP 주소와 포트 번호를 메모리의 제어영역에 기록한다.
- 이 정보는 일정 시간(보통 세그먼트 최대 생명주기의 두 배) 동안 유지된다.
- 이전 커넥션과 관련된 패킷이 그 사이에 생성되거나 중복되는 것을 방지하기 위함이다.
- 각각 하나의 클라이언트와 웹서버가 있는 경우 발신지 포트만 변경 가능하다.
- 서버가 초당 500개 이상 트랜잭션을 처리할 만큼 빠르지 않을 경우 포트 고갈 발생하지 않는다.

---

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있다.
- HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표로 구분하며, 그 값들은 다른 커넥션에 전달되지 않는다.
- 커넥션 헤더에 전달될 수 있는 세 가지 토큰:
  - HTTP 헤더 필드명: 이 커넥션에만 해당되는 헤더들을 나열. 다음 커넥션에 전달하면 안 됨(삭제).
  - 임시적인 토큰 값: 커넥션에 대한 비표준 옵션을 의미.
  - close 값: 커넥션이 작업이 완료되면 종료되어야 함을 의미.

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 나빠질 수 있다.
- 순차적인 처리로 인한 물리적인 지연과 하나의 데이터를 내려받는 중에는 웹페이지에 아무런 변화가 없어서 느끼는 심리적인 지연이 있다.
- 예를 들어 3개의 이미지가 있는 웹페이지를 보여주려면 네 개의 HTTP 트랜잭션이 필요하다(HTML 1개 + 이미지 3개).

---

## 4.4 병렬 커넥션

- 클라이언트가 여러 개의 HTTP 커넥션을 맺음으로써 HTTP 트랜잭션을 병렬로 처리할 수 있다.

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 여러 객체를 동시에 요청하면 전체 페이지 로딩 시간이 줄어든다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 네트워크 대역폭이 좁은 경우, 제한된 대역폭에서 객체 전송이 느리므로 병렬 커넥션의 장점이 거의 없다.
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 일으킨다.
- 브라우저는 실제로 병렬 커넥션을 사용하지만 적은 수의 병렬 커넥션만을 허용한다(보통 6~8개).

### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 여러 객체가 동시에 화면에 보이면서 내려받아지기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낀다.

---

## 4.5 지속 커넥션

- 사이트 지역성(site locality)으로 인해 서버에 HTTP 요청을 보낸 애플리케이션은 곧 그 서버에 또 요청을 보내게 된다.
- 지속 커넥션(persistent connection)은 처리가 완료된 후에도 TCP 커넥션을 계속 유지한다.

### 4.5.1 지속 커넥션 vs 병렬 커넥션

- 병렬 커넥션의 단점:
  - 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
  - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
  - 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.
- 지속 커넥션은 이런 단점을 보완한다.

### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

- HTTP/1.0에서는 설계상 결함이 있어 널리 쓰이지 않았다.
- HTTP/1.1에서는 설계가 개선되어 기본으로 활성화되어 있다.

### 4.5.3 Keep-Alive 동작

- Keep-Alive 헤더를 포함한 HTTP/1.0 요청을 받으면 응답 메시지에도 같은 헤더를 포함시켜 응답한다.
- 응답에 Keep-Alive 헤더가 없으면 클라이언트는 서버가 Keep-Alive를 지원하지 않으며 응답 메시지가 전송되고 나면 서버 커넥션을 끊을 것이라고 추정한다.

### 4.5.4 Keep-Alive 옵션

- Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청이다.
- timeout 파라미터로 커넥션 유지 시간을 지정할 수 있다.
- max 파라미터로 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지 지정할 수 있다.

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- Keep-Alive는 기본으로 사용되지 않는다.
- 커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해 보내야 한다.
- 클라이언트는 Connection: Keep-Alive 응답 헤더가 없으면 서버가 지속 커넥션을 지원하지 않는다고 추정하고 응답이 끝난 후 커넥션을 끊어야 한다.
- 엔티티 본문의 길이를 알아야 커넥션을 유지할 수 있다.
- 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 한다.
- Keep-Alive를 지원하지 않는 프락시와의 문제를 예상해야 한다.

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

- 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더를 그대로 다음 홉으로 전달한다.
- 멍청한 프락시는 Keep-Alive 커넥션을 제대로 처리하지 못하고 행(hang)에 빠진다.
- 커넥션이 유지되었다고 믿는 클라이언트에서 요청을 보냄에도 프락시는 그 요청을 무시한다.

### 4.5.7 Proxy-Connection 살펴보기

- 클라이언트의 요청이 중개 서버를 통해 이어지는 경우 Proxy-Connection 확장 헤더를 프락시에 전달한다.
- 프락시가 Proxy-Connection 헤더를 이해할 수 없더라도 문제없이 다음 서버로 전달한다.

### 4.5.8 HTTP/1.1의 지속 커넥션

- HTTP/1.1에서는 Keep-Alive 커넥션이 기본으로 활성화되어 있다.
- 트랜잭션이 끝난 후 커넥션을 끊으려면 Connection: close 헤더를 명시해야 한다.
- 클라이언트와 서버 모두 언제든지 커넥션을 끊을 수 있다.
- 엔티티 본문의 길이를 정확히 알아야 커넥션을 유지할 수 있다.
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 한다.

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈으면 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없다.
- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때만 커넥션을 지속시킬 수 있다.
- HTTP/1.1 프락시는 클라이언트의 커넥션 관련 지원 범위를 알고 있지 않은 한 지속 커넥션을 맺으면 안 된다.
- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야 한다.

---

## 4.6 파이프라인 커넥션

- HTTP/1.1은 지속 커넥션을 통해 요청을 파이프라이닝할 수 있다.
- 여러 개의 요청을 응답이 도착하기 전에 큐에 쌓아 보낼 수 있다.
- 제약사항:
  - HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안 된다.
  - 응답은 요청 순서와 같게 와야 한다.
  - 클라이언트는 커넥션이 언제 끊어지더라도 완료되지 않은 요청이 파이프라인에 있으면 다시 요청을 보낼 준비가 되어 있어야 한다.
  - POST 요청같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안 된다.

---

## 4.7 커넥션 끊기에 대한 미스터리

- 커넥션 관리, 특히 언제 어떻게 커넥션을 끊는가에는 명확한 기준이 없다.

### 4.7.1 '마음대로' 커넥션 끊기

- 어떠한 HTTP 클라이언트, 서버, 프록시든 언제든지 TCP 전송 커넥션을 끊을 수 있다.
- 지속 커넥션이 일정 시간 동안 유휴 상태에 있으면 서버는 그 커넥션을 끊을 수 있다.
- 서버가 커넥션을 끊은 시점에 클라이언트에서 데이터를 전송하면 문제가 생긴다.

### 4.7.2 Content-Length와 Truncation

- 각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다.
- 클라이언트나 프락시가 커넥션이 끊어졌다는 HTTP 응답을 받은 후, 실제 전달된 엔티티의 길이와 Content-Length가 일치하지 않거나 존재하지 않으면 수신자는 데이터의 정확한 길이를 서버에게 물어봐야 한다.
- 캐시 프락시 서버는 자신의 캐시에 잘못된 Content-Length를 가진 응답을 받아서 저장하지 말아야 한다.

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- HTTP 애플리케이션은 예상치 못한 쓰기 에러에 대해서 적절하게 대응할 준비가 되어 있어야 한다.
- 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 한 다시 보내야 한다.
- 파이프라인이 아닌 경우에는 완료되지 않은 요청이 서버에서 처리 완료되었는지 클라이언트가 판단할 수 없다.

### 4.7.4 우아한 커넥션 끊기

- TCP 커넥션은 기본적으로 양방향이다.
- TCP 커넥션의 양쪽에는 읽고 쓰기 위한 입력 큐와 출력 큐가 있다.
- 한쪽의 출력 큐에 있던 데이터는 다른 쪽의 입력 큐에 보관된다.

**전체 끊기와 절반 끊기**
- 애플리케이션은 TCP 입력 채널과 출력 채널 중 하나만 끊거나 둘 다 끊을 수 있다.
- close() 호출은 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는다(전체 끊기).
- shutdown()은 입력 채널이나 출력 채널 둘 중 하나를 개별적으로 끊을 수 있다(절반 끊기).

**우아하게 커넥션 끊기**
- 애플리케이션이 출력 채널을 끊으면 서버는 데이터 전송이 끝났음을 알게 된다.
- 애플리케이션이 입력 채널을 끊으면 입력 큐에 있는 데이터가 모두 제거된다.
- 우아한 종료를 위해서는 애플리케이션은 먼저 자신의 출력 채널을 끊고, 반대편도 출력 채널을 끊을 때까지 데이터 또는 스트림의 끝을 기다리는 것이 좋다.
- 양쪽에서 더는 데이터를 전송할 것이 없다는 것을 알게 되면 그때 커넥션을 끊어 리셋 에러가 발생하지 않는다.
- 하지만 애플리케이션이 우아한 종료를 구현했다고 보장할 수 없다.
