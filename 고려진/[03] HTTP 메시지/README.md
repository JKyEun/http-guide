# 3장. HTTP 메시지
- [3.1 메시지의 흐름](#3.1-메시지의-흐름)
- [3.2 메시지의 각 부분](#3.1-메시지의-각-부분)
- [3.3 메서드](#3.3-메서드)
- [3.4 상태 코드](#3.4-상태-코드)
- [3.5 헤더](#3.5-헤더)

---

## 3.1 메시지의 흐름

### 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

HTTP는 인바운드(inbound)와 아웃바운드(outbound)라는 용어를 사용하여 트랜잭션 방향을 표현한다.

- 인바운드: 메시지가 원 서버(origin server)로 향하는 것
- 아웃바운드: 메시지가 사용자 에이전트로 돌아오는 것

모든 메시지는 인바운드로 흘러가며, 요청이든 응답이든 관계없이 모든 메시지는 다운스트림(downstream)으로 흐른다.

## 3.2 메시지의 각 부분

HTTP는 세 부분으로 구성된다.

1. 시작줄(start line): 메시지의 첫 줄
2. 헤더 블록(header): 0개 이상의 헤더 필드
3. 본문(body): 선택적인 데이터 블록

시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다. 각 줄은 캐리지 리턴(13)과 개행 문사(10)로 구성된 CRLF로 끝난다.  
이 줄바꿈 문자열을 "CRLF"라고 부른다.

본문은 텍스트나 이진 데이터를 포함할 수 있으며, 비어있을 수도 있다.

### 3.2.1 메시지 문법
```HTTP
요청 메시지의 형식
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

```HTTP
응답 메시지의 형식
<버전> <상태 코드> <사유 구절(reason-phrase)>
<헤더>

<엔터티 본문>
```

- **메서드(method)**: 클라이언트가 서버에게 요청하는 동작 (GET, POST, HEAD 등)
- **요청 URL**: 요청 대상 리소스를 지정하는 완전한 URL 또는 경로
- **버전(version)**: 메시지에서 사용 중인 HTTP 버전 (HTTP/1.1 등)
- **상태 코드(status code)**: 요청 중 무엇이 일어났는지 설명하는 세 자리 숫자
- **사유 구절(reason-phrase)**: 상태 코드의 의미를 사람이 이해할 수 있게 설명하는 짧은 문구
- **헤더(headers)**: 0개 이상의 헤더 필드. 이름, 콜론(:), 선택적 공백, 값, CRLF 순서로 구성
- **엔터티 본문(entity body)**: 임의의 데이터 블록. 모든 메시지가 본문을 갖는 것은 아님

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 하는지 말해주고, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

**요청줄(Request line)**

요청 메시지의 시작으로, 서버에게 무엇을 해야 하는지 말해준다.

```HTTP
GET /test/hi-there.txt HTTP/1.1
```

- GET: method
- /test/hi-there.txt: 요청 url
- HTTP/1.1: HTTP 버전

**응답줄(Response line)**

응답 메시지의 시작줄으로, 수행 결과에 대한 상태 정보를 클라이언트에게 돌려준다.
```HTTP
HTTP/1.1 200 OK
```

- HTTP/1.1: HTTP 버전
- 200: 상태 코드
- OK: 사유 구절

**상태 코드**

상태 코드는 클라이언트에게 무엇이 일어났는지 말해준다. 세 자리 숫자로 표현되며, 첫 번째 자리는 상태의 일반적인 분류를 나타낸다.

**버전 번호**

HTTP 버전은 HTTP/x.y 형식으로 표현된다.
- HTTP/1.1: HTTP 애플리케이션이 프로토콜의 메이저 버전 1, 마이너 버전 1을 따른다는 의미
- 버전 번호는 HTTP 애플리케이션이 지원하는 가장 높은 버전을 가리킴

**사유 구절(Reason-Phrase)**

상태 코드의 의미를 사람이 이해할 수 있도록 설명하는 짧은 텍스트이다. 단지 설명만을 위해 존재하며, 프로그램은 상태 코드만 사용한다.

예:
- `200 OK`
- `200 Document attached`
- `200 Success`
- `200 All's cool, dude`

모두 동일한 성공 상태를 나타낸다.

### 3.2.3 헤더

시작줄 다음에는 0개 이상의 HTTP 헤더 필드가 옵니다. HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더합니다.

**헤더의 기본 형식:**
```
이름: 값
```

예시:
```HTTP
Content-Length: 19
Content-Type: text/plain
Accept: text/html
```

**헤더의 분류:**

1. **일반 헤더(General Headers)**: 요청과 응답 양쪽에 모두 나타날 수 있음
2. **요청 헤더(Request Headers)**: 요청에 대한 부가 정보 제공
3. **응답 헤더(Response Headers)**: 응답에 대한 부가 정보 제공
4. **엔터티 헤더(Entity Headers)**: 본문 크기와 콘텐츠, 리소스 자체를 서술
5. **확장 헤더(Extension Headers)**: 명세에 정의되지 않은 새로운 헤더

**헤더를 여러 줄로 나누기**

긴 헤더 줄은 여러 줄로 나눌 수 있습니다. 추가 줄 앞에는 최소 하나의 스페이스나 탭 문자가 와야 합니다.
```HTTP
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
  Version 1.0
```

위 예시에서 `Server` 헤더의 값은 "Test Server Version 1.0"입니다.

### 3.2.4 엔터티 본문

HTTP 메시지의 세 번째 부분은 선택적인 엔터티 본문입니다. 엔터티 본문은 HTTP가 수송하도록 설계된 것들의 화물입니다.

HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있습니다.

### 3.2.5 버전 0.9 메시지

HTTP/0.9는 HTTP 프로토콜의 초기 버전으로, 매우 단순한 구조를 가집니다.

**HTTP/0.9 요청:**
- 메서드와 요청 URL만 포함
- 버전 정보, 상태 코드, 사유 구절, 헤더 없음
```HTTP
GET /index.html
```

**HTTP/0.9 응답:**
- HTML 응답만 포함
- 헤더나 버전 정보 없음
```html

Hello World

```

HTTP/0.9는 오늘날 거의 사용되지 않지만, 일부 오래된 클라이언트나 서버는 여전히 지원할 수 있습니다.

## 3.3 메서드

HTTP는 여러 가지 종류의 요청 명령을 지원합니다. 이를 HTTP 메서드라고 합니다. 모든 서버가 모든 메서드를 구현하는 것은 아닙니다.

### 3.3.1 안전한 메서드(Safe Methods)

HTTP는 **안전한 메서드**라 불리는 메서드 집합을 정의합니다. GET과 HEAD 메서드는 안전한 것으로 간주됩니다.

안전한 메서드의 목적은 서버에 어떤 작용도 없는 HTTP 요청을 만들 수 있도록 하는 것입니다. 즉, 서버에 부작용(side effect)을 일으키지 않습니다.

안전한 메서드가 아무 작용도 하지 않는다는 보장은 없지만, 클라이언트가 안전한 메서드를 사용하면 서버에 어떤 해로운 일도 일어나지 않으리라 믿어도 된다는 의미입니다.

### 3.3.2 GET

GET은 가장 흔히 쓰이는 메서드입니다. 주로 서버에게 리소스를 요청하기 위해 사용됩니다.
```HTTP
GET /index.html HTTP/1.1
Host: www.example.com
```

### 3.3.3 HEAD

HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려줍니다. 엔터티 본문은 절대 반환되지 않습니다.

**HEAD의 용도:**
- 리소스를 가져오지 않고도 타입 등의 정보 알아내기
- 응답 상태 코드를 통해 개체의 존재 확인
- 헤더를 확인하여 리소스가 변경되었는지 검사

HEAD를 사용하면 낭비되는 대역폭 없이 리소스에 대해 알 수 있습니다.
```HTTP
HEAD /index.html HTTP/1.1
Host: www.example.com
```

서버 개발자는 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 합니다.

### 3.3.4 PUT

PUT 메서드는 서버에 문서를 씁니다. PUT은 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것입니다.
```HTTP
PUT /product.txt HTTP/1.1
Host: www.example.com
Content-type: text/plain
Content-length: 18

New product data!
```

PUT은 콘텐츠를 변경할 수 있게 해주므로, 많은 웹 서버는 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구합니다.

### 3.3.5 POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었습니다. 실제로 HTML 폼을 지원하기 위해 흔히 사용됩니다.
```HTTP
POST /login HTTP/1.1
Host: www.example.com
Content-type: application/x-www-form-urlencoded
Content-length: 30

username=john&password=secret
```

POST는 서버에 데이터를 보내는 데 사용되며, 일반적으로 HTML 폼의 데이터를 담아 서버로 전송합니다.

### 3.3.6 TRACE

클라이언트가 요청을 할 때, 그 요청은 방화벽, 프록시, 게이트웨이 등의 애플리케이션을 통과할 수 있습니다. 이들 각각은 원래의 HTTP 요청을 수정할 수 있는 기회를 가집니다.

TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줍니다.

TRACE 요청은 목적지 서버에서 "루프백(loopback)" 진단을 시작합니다. 요청이 최종 목적지 서버에 도착했을 때, 서버는 TRACE 응답을 돌려보냅니다. 이때 자신이 받은 요청 메시지를 본문에 넣어서 보냅니다.
```HTTP
TRACE / HTTP/1.1
Host: www.example.com
```

응답:
```HTTP
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 96

TRACE / HTTP/1.1
Host: www.example.com
Via: 1.1 proxy.example.com
```

TRACE는 주로 진단을 위해 사용됩니다. 예를 들어, 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있습니다.

TRACE 요청은 엔터티 본문을 보낼 수 없습니다. TRACE 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있습니다.

### 3.3.7 OPTIONS

OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봅니다. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있습니다.
```HTTP
OPTIONS * HTTP/1.1
Host: www.example.com
```

응답:
```HTTP
HTTP/1.1 200 OK
Allow: GET, POST, PUT, DELETE, HEAD, OPTIONS
```

이것은 여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에 제공합니다.

### 3.3.8 DELETE

DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청합니다.
DELETE /product.txt HTTP/1.1
Host: www.example.com

그러나 클라이언트는 삭제가 수행되는 것을 보장할 수 없습니다. HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문입니다.

### 3.3.9 확장 메서드

HTTP는 필요에 따라 확장할 수 있도록 설계되었습니다. 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드입니다.

**WebDAV 확장 메서드 예시:**
- **LOCK**: 사용자가 리소스를 잠글 수 있게 해줌
- **MKCOL**: 문서 컬렉션 생성
- **COPY**: 서버의 리소스 복사
- **MOVE**: 서버의 리소스 이동

확장 메서드를 다룰 때는 "엄격하게 보내고 관대하게 받아들이기"가 좋은 지침입니다. 이해할 수 없는 메서드가 담긴 요청을 받았을 때는 501 Not Implemented 상태 코드로 응답하는 것이 바람직합니다.

## 3.4 상태 코드

HTTP 상태 코드는 크게 다섯 가지로 분류됩니다.

### 전체 범위

| 전체 범위 | 정의된 범위 | 분류 |
|----------|-----------|------|
| 100-199 | 100-101 | 정보성 상태 코드 |
| 200-299 | 200-206 | 성공 상태 코드 |
| 300-399 | 300-305 | 리다이렉션 상태 코드 |
| 400-499 | 400-415 | 클라이언트 에러 상태 코드 |
| 500-599 | 500-505 | 서버 에러 상태 코드 |

### 3.4.1 100-199: 정보성 상태 코드

HTTP/1.1에서 도입되었으며, 상대적으로 새로운 코드입니다.

**100 Continue**

요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 보내야 함을 의미합니다. 서버는 요청을 받아 이행한 후 반드시 최종 응답을 보내야 합니다.

클라이언트와 100 Continue:
- 클라이언트가 엔터티를 서버에 보내려 하고 있고, 서버가 거부할 것 같으면 엔터티를 보내기 전에 100 Continue 응답을 기다려야 합니다
- 클라이언트는 `Expect: 100-continue` 헤더를 보냅니다
- 클라이언트는 타임아웃 후 응답 없으면 그냥 엔터티를 보내야 합니다

서버와 100 Continue:
- 서버가 `Expect: 100-continue`가 포함된 요청을 받으면, 100 Continue나 에러 코드로 응답해야 합니다
- 서버는 엔터티를 읽기 전에 절대 100 Continue 상태 코드를 보내면 안 됩니다

프록시와 100 Continue:
- 프록시가 다음 홉(next-hop) 서버가 HTTP/1.1을 따르거나 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함시켜 전달해야 합니다

**101 Switching Protocols**

클라이언트가 Upgrade 헤더를 보내 서버에게 프로토콜 변경을 요청했고, 서버가 그것에 동의했음을 의미합니다.

## 3.5 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용됩니다.

### 3.5.1 일반 헤더(General Headers)

클라이언트와 서버 양쪽 모두가 사용합니다. 클라이언트, 서버 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용됩니다.

일반적인 정보성 헤더의 예:
```HTTP
Connection: close
Date: Tue, 3 Oct 1997 02:16:03 GMT
MIME-Version: 1.0
Trailer: chunked
Transfer-Encoding: chunked
Update: Mon, 22 Dec 2003 15:00:00 GMT
Via: 1.1 proxy.example.com
```

**일반 캐시 헤더**

HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 사본을 보관해 두고 캐시할 수 있도록 해주는 최초의 헤더를 도입했습니다.

### 3.5.2 요청 헤더(Request Headers)

요청 메시지에만 의미를 갖는 헤더입니다. 요청이 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지, 클라이언트의 선호나 능력에 대한 정보를 제공합니다.

**Accept 관련 헤더**

클라이언트가 무엇을 원하고 무엇을 할 수 있는지, 무엇을 원하지 않는지 알려줍니다.  
```HTTP
Accept: /
Accept-Charset: iso-8859-1
Accept-Encoding: gzip
Accept-Language: en, fr
```

- **Accept**: 서버에게 어떤 미디어 타입을 보내도 되는지 말해줍니다
- **Accept-Charset**: 서버에게 어떤 문자집합을 보내도 되는지 말해줍니다
- **Accept-Encoding**: 서버에게 어떤 인코딩을 보내도 되는지 말해줍니다
- **Accept-Language**: 서버에게 어떤 언어를 보내도 되는지 말해줍니다
- **TE**: 서버에게 어떤 확장된 전송 코딩을 사용해도 되는지 말해줍니다

**조건부 요청 헤더**

클라이언트는 요청에 제약을 넣을 수 있습니다. 예를 들어, 클라이언트가 이미 어떤 문서의 사본을 갖고 있다면, 서버에게 클라이언트가 갖고 있는 것과 다를 때만 전송해 달라고 요청할 수 있습니다.

**요청 보안 헤더**

HTTP는 자체적으로 간단한 인증요구/응답 체계를 갖고 있다. 요청하는 클라이언트가 트랜잭션을 약간이라도 더 안전하게 만들기 위해 리소스에 접근하기 전에 자신을 인증하도록 요구한다.
```HTTP
Authorization: Basic YnJpYW46Z3Vlc3Q=
Cookie: session_id=abc123
Cookie2: Version=1
```

**프록시 요청 헤더**
```HTTP
Max-Forwards: 5
Proxy-Authorization: Basic dGVzdDp0ZXN0
Proxy-Connection: Keep-Alive
```

### 3.5.3 응답 헤더(Response Headers)

응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖는다.
```HTTP
Age: 3600
Public: GET, HEAD, PUT
Retry-After: 3600
Server: Apache/2.4.1 (Unix)
Title: Document Title
Warning: 110 Response is stale
```

**협상 헤더**

서버와 클라이언트가 어떤 리소스의 여러 가지 표현 중 어느 것을 택할 것인가에 대한 협상을 할 수 있다.

**응답 보안 헤더**

HTTP 인증요구/응답체계에서 응답측에 해당하는 요청 보안 헤더가 있다.

### 3.5.4 엔터티 헤더(Entity Headers)

엔터티 본문에 대한 헤더를 말합니다. 예를 들어, 엔터티 본문에 어떤 타입의 데이터가 담겨있는지 말해줄 수 있습니다.
```HTTP
Allow: GET, HEAD
Location: http://www.example.com/new-location
```
콘텐츠 헤더, 엔티티 캐싱 헤더 등이 있다.
