## 1장 HTTP 개관 - 요약

### 1.1 HTTP: 인터넷의 멀티미디어 배달부

**HTTP의 역할**

- 전 세계의 웹 브라우저, 서버, 웹 애플리케이션은 모두 HTTP(Hypertext Transfer Protocol)를 통해 서로 대화함
- HTTP는 신뢰성 있는 데이터 전송 프로토콜 사용
- 전송 중 데이터가 손상되거나 꼬이지 않음을 보장

### 1.2 웹 클라이언트와 서버

- 웹 콘텐츠는 웹 서버에 존재
- 웹 서버는 HTTP 프로토콜로 의사소통하므로 HTTP 서버라고도 함
- 클라이언트(웹 브라우저)는 서버에게 HTTP 요청을 보냄
- 서버는 요청받은 데이터를 HTTP 응답으로 돌려줌

예시

- 클라이언트가 http://www.oreilly.com/index.html 페이지를 요청
- HTTP는 요청을 www.oreilly.com 서버로 보냄
- 서버는 객체("/index.html")를 찾고, 성공하면 타입, 길이 등과 함께 HTTP 응답으로 반환

### 1.3 리소스

**리소스의 개념**

- 웹 서버는 리소스를 관리하고 제공함
- 리소스는 웹 콘텐츠의 원천 - 가장 단순하게는 웹 서버의 파일 시스템에 있는 정적 파일
- 정적 파일: 텍스트, HTML, 마이크로소프트 워드 파일, JPEG 이미지, AVI 동영상 파일 등

- 동적 콘텐츠: 리소스는 반드시 정적 파일이어야 할 필요는 없음

  - 요청에 따라 콘텐츠를 생성하는 프로그램도 리소스가 될 수 있음
  - 예: 주식 거래, 부동산 데이터베이스 검색, 온라인 쇼핑몰에서 선물 구입 등

### 1.3.1 미디어 타입

**MIME 타입의 역할**

- 인터넷은 수천 가지 데이터 타입을 다루므로, HTTP는 웹에서 전송되는 객체 각각에 MIME 타입을 붙임
- MIME (Multipurpose Internet Mail Extensions): 원래는 이메일 첨부 파일 표시용, 워낙 잘 동작해서 HTTP에도 채택
- 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙임

**MIME 타입 구조**
Content-type: image/jpeg
Content-length: 12984

```
- 주 타입(primary object type) / 부 타입(specific subtype)
- 예시:
  - HTML: `text/html`
  - plain ASCII: `text/plain`
  - JPEG: `image/jpeg`
  - GIF: `image/gif`
```

### 1.3.2 URI

**URI의 개념**

- 웹 서버 리소스는 각자 **이름**을 가짐
- 클라이언트는 관심 있는 리소스를 지목할 수 있음
- **URI (Uniform Resource Identifier)**: 통합 자원 식별자
- 인터넷의 우편물 주소 같은 것으로, 정보 리소스를 고유하게 식별하고 위치 지정

**URI의 두 가지 형태**

- **URL** (Uniform Resource Locator)
- **URN** (Uniform Resource Name)

### 1.3.3 URL

**URL의 구조**

- 리소스가 **어디에 있는지** 설명
- 대부분의 URL은 세 부분으로 구성:
  1. **스킴(scheme)**: 리소스에 접근하기 위한 프로토콜 (예: `http://`)
  2. **서버의 인터넷 주소** (예: `www.joes-hardware.com`)
  3. **웹 서버의 리소스** (예: `/specials/saw-blade.gif`)

**URL 예시**

`http://www.joes-hardware.com/specials/saw-blade.gif`

- 이 URL은 HTTP 프로토콜을 사용해
- www.joes-hardware.com 서버로 가서
- /specials/saw-blade.gif 라는 리소스를 가져오라는 의미

**오늘날 대부분의 URI는 URL입니다.**

### 1.3.4 URN

**URN의 특징:**

- 리소스의 **이름**으로 사용
- 리소스가 어디 있든 상관없이 그 이름만으로 식별
- 위치에 독립적이므로, 리소스가 이동해도 URN은 변하지 않음
- 여러 곳에 분산 복사된 리소스도 하나의 URN으로 접근 가능

**URN의 현실:**

- 아직 실험 단계에 있음
- 리소스 위치를 분석하기 위한 인프라 지원 필요
- 인프라 부족으로 **아직 채택되지 않음**
- 전망은 분명 밝다.

**URN 예시:**

urn:ietf:rfc:2141

### 1.4 트랜잭션

**HTTP 트랜잭션의 구성**

- 클라이언트가 웹 서버와 리소스를 주고받기 위해 HTTP를 이용
- HTTP 트랜잭션은 요청 명령(클라이언트 → 서버)과 응답 결과(서버 → 클라이언트)로 구성
- 이 상호작용은 HTTP 메시지라는 정형화된 데이터 덩어리를 이용해 이루어짐

### 1.4.1 메서드

**HTTP 메서드의 역할**

- HTTP는 메서드라고 불리는 여러 가지 종류의 요청 명령을 지원
- 모든 HTTP 요청 메시지는 한 개의 메서드를 가짐
- 메서드는 서버에게 어떤 동작이 취해져야 하는지 말해줌

**주요 HTTP 메서드 5가지**

| HTTP 메서드 | 설명                                                                |
| ----------- | ------------------------------------------------------------------- |
| GET         | 서버에서 클라이언트로 지정한 리소스를 보내라                        |
| PUT         | 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라 |
| DELETE      | 지정한 리소스를 서버에서 삭제하라                                   |
| POST        | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라         |
| HEAD        | 지정한 리소스에 대한 응답에서 HTTP 헤더 부분만 보내라               |

### 1.4.2 상태 코드

**상태 코드의 역할**

- 모든 HTTP 응답 메시지는 상태 코드와 함께 반환됨
- 상태 코드는 클라이언트에게 요청이 성공했는지 추가 조치가 필요한지 알려주는 세 자리 숫자
- 각 숫자는 상태 코드 및 그 의미를 표시하는 1~5번 내의 범위

**주요 HTTP 상태 코드**

| HTTP 상태 코드 | 설명                                          |
| -------------- | --------------------------------------------- |
| 200            | 좋다. 문서가 바르게 반환되었다                |
| 302            | 다시 보내라. 다른 곳에 가서 리소스를 가져가라 |
| 404            | 없음. 리소스를 찾을 수 없다                   |

**상태 코드와 사유 구절**

- HTTP는 각 숫자 상태 코드에 텍스트로 된 "사유 구절"(reason phrase)도 함께 보냄
- 실제 숫자 코드만으로도 충분히 사유 전달
- HTTP 소프트웨어는 상태 코드를 사유 구절과 함께 전송 및 응답 처리

**예시**

```
200 OK
200 Document attached
200 Success
200 All's cool, dude
```

→ HTTP 상태 코드는 3자릿수 숫자가 실질적임

### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다

**웹페이지의 구성**

- 애플리케이션은 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행
- 웹 브라우저는 시각적으로 풍부한 웹페이지를 가져올 때, 대량의 HTTP 트랜잭션 실행

**예시**

페이지 레이아웃을 가져오는 HTML, 텍스트 및 이미지 파일, 자바스크립트, 그래픽 로고 등

### 1.5 메시지

**HTTP 메시지의 3가지 부분**

1. **시작줄 (Start Line)**

   - 메시지의 첫 줄은 시작줄로, 요청이라면 무엇을 해야 하는지 응답이라면 무슨 일이 일어났는지 나타냄

2. **헤더 (Header)**

   - 시작줄 다음에는 0개 이상의 헤더 필드가 이어짐
   - 각 헤더 필드는 쌍점(:)으로 구분되어 있는 하나의 이름과 하나의 값으로 구성
   - 헤더는 추가 정보를 전달하며 끝을 나타내는 빈 줄(CRLF)로 끝남

3. **본문 (Body)**
   - 빈 줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 올 수 있음
   - 요청의 본문은 웹 서버로 데이터를 실어 보내며, 응답의 본문은 클라이언트로 데이터를 반환
   - 문자열 데이터뿐만 아니라 이진 데이터도 포함할 수 있음 (이미지, 오디오, 텍스트, 동영상 등 다양한 콘텐츠)
   - 본문은 없을 수도 있음

### 1.5.1 간단한 메시지의 예

**요청 메시지 예시**

```
GET /test/hi-there.txt HTTP/1.1
Accept: text/*
Host: www.joes-hardware.com
```

- 그림 1-6에 간단한 메시지 예시가 주어짐
- 클라이언트는 HTTP 요청 메시지를 보냄
- 요청 메시지는 `/tools.html`이라는 HTML 페이지를 GET 메서드로 요청
- 호스트 정보와 있는 텍스트 타입만 받아들인다는 정보를 포함

**응답 메시지 예시**

```
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 19

Hi! I'm a message!
```

- 서버는 HTTP 응답 메시지를 돌려줌
- 응답에는 HTTP 버전 번호(HTTP/1.0), 성공 상태 코드(200), 사유 구절(OK), 응답 헤더 필드, 그리고 응답 본문이 포함됨
- 본문의 MIME 타입은 Content-Type 헤더에 의해 text/plain으로 지정됨

### 1.6 TCP 커넥션

### 1.6.1 TCP/IP

<img width="379" height="320" alt="Image" src="./images/level.jpg" />

**TCP/IP의 역할**

- HTTP는 애플리케이션 계층 프로토콜
- HTTP는 네트워크 통신의 세세한 사항을 신경 쓰지 않음
- 대신 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에 의존

**TCP가 제공하는 기능**

- 오류 없는 데이터 전송
- 순서에 맞는 전달 (데이터는 언제나 보낸 순서대로 도착)
- 조각나지 않는 데이터 스트림 (언제든 보낸 크기로 전달)

**HTTP 네트워크 프로토콜 스택**

```
HTTP (애플리케이션 계층)
↓
TCP (전송 계층)
↓
IP (네트워크 계층)
↓
네트워크를 위한 링크 인터페이스 (데이터 링크 계층)
↓
물리적 네트워크 하드웨어 (물리 계층)
```

**TCP/IP의 특징**

- 인터넷 자체가 전 세계의 컴퓨터와 네트워크 장치를 연결하는 **TCP/IP**에 기초
- TCP/IP는 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합
- TCP/IP는 각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해줌
- 일단 TCP 커넥션이 맺어지면, 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나, 손상되거나, 순서가 뒤바뀌어 수신되는 일은 결코 없음

**네트워크 개념상, HTTP 프로토콜은 TCP 위의 계층입니다.** HTTP는 자신의 메시지 데이터를 전송하기 위해 TCP를 사용합니다. 이와 유사하게 TCP는 IP 위의 계층입니다.

### 1.6.2 접속, IP 주소 그리고 포트번호

**HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 하기 전에**

- 인터넷 프로토콜(IP) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 **TCP/IP 커넥션**을 맺어야 함

**TCP 커넥션을 맺는 과정**

- TCP는 먼저 서버의 **IP 주소**와 그 서버에서 실행 중인 **포트번호**가 필요
- 이는 마치 회사의 전화번호(IP 주소)와 전화를 받을 사람의 내선번호(포트번호)와 비슷함
- TCP에서는 서버 컴퓨터에 대한 IP 주소와 그 서버에서 실행 중인 프로그램이 사용하는 포트번호가 필요함

### 1.6.3 텔넷(Telnet)을 이용한 실제 예제

**HTTP는 TCP/IP를 사용하므로 텔넷 유틸리티를 이용해 직접 서버와 대화해 볼 수 있습니다.**

**예제 실습 과정**

**1단계: www.joes-hardware.com의 IP 주소 찾기**

```
http://207.200.83.29:80/index.html
```

- 먼저 URL의 호스트 명을 IP 주소로 변환
- 대부분의 DNS라는 장치를 사용해 호스트 명을 쉽게 IP로 변환 가능

**2단계: 포트번호 확인**

- URL에 포트번호가 없으면 기본값 80으로 간주
- 이 예제에서는 포트 80을 명시적으로 지정

**3단계: 웹 서버에 접속**

- 텔넷을 통해 연결: `telnet 207.200.83.29 80`

**4단계: HTTP 요청 보내기**

```
GET /tools.html HTTP/1.1
Host: www.joes-hardware.com
```

**5단계: 응답 받기**

- 타이핑을 멈추면 서버는 응답 메시지 반환
- 연결이 서버에 의해 닫힘

**주요 포인트**

- (a) 텔넷으로는 서버의 DNS 이름과 호스트 명을 추출함
- (b) 텔넷으로는 서버의 호스트 명을 IP로 변환함
- (c) 텔넷으로는 URL에서 포트번호(있다면) 추출함
- (d) 텔넷으로는 웹 서버와 TCP 커넥션을 맺음
- (e) 텔넷으로는 서버에 HTTP 요청을 보냄
- (f) 서버는 텔넷 클라이언트에 HTTP 응답을 돌려줌
- (g) 커넥션이 닫히면, 텔넷 클라이언트는 온라인 상태가 아님

### [추가] 텔넷과 넷캣(netcat)

**텔넷(Telnet)이란**

- 원격 터미널 접속을 위한 프로토콜이지만, HTTP 테스트에도 활용 가능
- HTTP는 텍스트 기반 프로토콜이므로 TCP 연결을 통해 직접 요청/응답 확인 가능
- 브라우저 없이도 HTTP 메시지 구조를 직접 확인할 수 있어 학습에 유용

**넷캣(netcat, nc)이란**

- 텔넷의 대안으로 사용되는 네트워크 유틸리티
- macOS에서는 기본적으로 `telnet`이 설치되어 있지 않지만, `nc`는 기본 제공
- TCP/UDP 연결을 만들고 데이터를 읽고 쓸 수 있음

**실제 HTTP 요청 전송 예제**

**예제 1: example.com에 GET 요청 보내기**

```bash
echo -e "GET / HTTP/1.1\nHost: example.com\n\n" | nc example.com 80
```

**실제 요청 메시지:**

```
GET / HTTP/1.1
Host: example.com

```

**실제 응답 예시:**

```
HTTP/1.1 200 OK
Content-Type: text/html
ETag: "bc2473a18e003bdb249eba5ce893033f:1760028122.592274"
Last-Modified: Thu, 09 Oct 2025 16:42:02 GMT
Cache-Control: max-age=86000
Date: Sun, 02 Nov 2025 14:58:37 GMT
Content-Length: 513
Connection: keep-alive

<!doctype html><html lang="en"><head><title>Example Domain</title>...
```

**주요 포인트**

- HTTP 요청은 시작줄, 헤더, 빈 줄 순서로 구성
- `Host` 헤더는 필수 (HTTP/1.1)
- 응답에는 상태 코드, 헤더, 본문이 포함됨
- TCP 연결을 통해 직접 HTTP 메시지를 보내고 받을 수 있음을 확인 가능

### 1.7 프로토콜 버전

**HTTP 프로토콜의 여러 버전**

| 버전      | 설명                                                                                                                                                                                                    |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| HTTP/0.9  | 1991년 프로토타입. 심각한 디자인 결함, 구식 클라이언트 전용. GET 메서드만 지원, MIME 타입/헤더/버전 번호 미지원. 간단한 HTML 객체용. HTTP/1.0으로 빠르게 대체됨                                         |
| HTTP/1.0  | 처음 널리 쓰인 버전. 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리 추가. 시각적으로 매력적인 웹페이지와 상호작용하는 폼 실현. 웹 대중화에 기여. 잘 정의되지 않은 명세, 용례들의 모음에 가까움 |
| HTTP/1.0+ | 1990년대 중반 웹 팽창 시기, 많은 인기 있는 웹 클라이언트와 서버들이 기능 추가. "keep-alive" 커넥션, 가상 호스팅, 프락시 연결 지원 등 비공식적 표준 기능 포함. 규격 외 확장 버전                         |
| HTTP/1.1  | HTTP 설계의 구조적 결함 교정, 성능 최적화, 잘못된 기능 제거. 복잡한 웹 애플리케이션과 배포 지원 (1990년대 후반부터 사용). 현재 HTTP 버전                                                                |
| HTTP/2.0  | HTTP/1.1 성능 개선을 위한 SPDY 기반 프로토콜 (설계 진행 중). 10장 참조                                                                                                                                  |

### [추가] 우리는 어떤 프로토콜을 쓰고 있을까

<img width="379" height="320" alt="Image" src="./images/protocol-dev-tool.png" />

HTTP/3는 UDP를 기반으로 하는 QUIC를 사용

**HTTP/3가 UDP를 선택한 이유**

- UDP는 기능이 거의 없는 백지 상태 프로토콜이라 커스터마이징이 용이함
- TCP는 오래된 프로토콜로 커널 레벨에 깊숙이 들어가 있어 수정이 어려움
- QUIC은 UDP 위에 TCP의 신뢰성 기능을 구현하여 속도와 신뢰성을 모두 확보

**QUIC의 주요 개선 사항**

- **연결 설정 레이턴시 감소**: TCP의 3 Way Handshake를 생략하여 첫 연결을 1 RTT로 단축 (TCP+TLS는 3 RTT 필요)
- **HOLB 문제 해결**: 멀티플렉싱을 통해 하나의 스트림 문제가 다른 스트림에 영향을 주지 않음
  - TCP는 패킷이 유실되거나 오류가 있을때 재전송을하는데 이 재전송하는 패킷에 지연이 발생하면 결국 HOLB(Head Of Line Blocking) 문제가 발생
- **IP 변경 시 연결 유지**: Connection ID를 사용하여 클라이언트 IP가 바뀌어도 연결 유지
- **패킷 손실 감지 시간 단축**: 고유한 패킷 번호를 사용하여 재전송 모호성 문제 해결

`근데 왜 우리 사이트는 느릴까`

### 1.8 웹의 구성요소

이 장에서는 웹 애플리케이션(웹 브라우저와 웹 서버)이 기본적인 트랜잭션을 구현하기 위해 메시지를 주고받는 방식에 중점을 둠. 인터넷과 상호작용할 수 있는 다양한 웹 애플리케이션에 대해 간략히 설명함.

**주요 웹 구성요소**

- **프락시 (Proxy)**: 클라이언트와 서버 사이에 위치한 HTTP 중개자
- **캐시 (Cache)**: 자주 찾는 웹 페이지를 클라이언트 가까이에 보관하는 HTTP 저장소
- **게이트웨이 (Gateway)**: 다른 애플리케이션과 연결된 특별한 웹 서버
- **터널 (Tunnel)**: 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- **에이전트 (Agent)**: 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램

### 1.8.1 프락시

**프락시의 역할**

- 클라이언트와 서버 사이에 위치하여 클라이언트의 모든 HTTP 요청을 받아 서버에 전달함 (대개 요청을 수정한 뒤에)
- 사용자를 위한 프락시로 동작하며 사용자를 대신해서 서버에 접근함
- 주로 보안을 위해 사용되며, 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 함
- 요청과 응답을 필터링함 (예: 애플리케이션 바이러스 검출, 성인 콘텐츠 차단)

**프락시 흐름**

클라이언트 → 프락시 → 인터넷 → 서버

자세한 내용은 6장에서 다룸.

### 1.8.2 캐시

**캐시의 역할**

- 웹 캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해두는 특별한 종류의 HTTP 프락시 서버
- 클라이언트가 같은 문서를 요청하면 캐시가 갖고 있는 사본을 받을 수 있음
- 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 더 빨리 문서를 다운받을 수 있음
- HTTP는 캐시를 효율적으로 동작하게 하고, 캐시된 콘텐츠를 최신 버전으로 유지하며 동시에 프라이버시를 보호하기 위한 많은 기능을 정의함

**캐시 흐름**

클라이언트 → 프락시 캐시 → 원본 서버 (프락시 캐시 내부에 문서 사본 저장)

자세한 내용은 7장에서 다룸.

### 1.8.3 게이트웨이

**게이트웨이의 역할**

- 다른 서버들의 중개자로 동작하는 특별한 서버
- HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용됨
- 항상 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룸
- 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못함

**HTTP/FTP 게이트웨이 예시**

- FTP URI에 대한 HTTP 요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져옴
- 받아온 문서는 HTTP 메시지에 담겨 클라이언트에게 보내짐

**게이트웨이 흐름**

클라이언트 (HTTP) → HTTP/FTP 게이트웨이 (FTP) → FTP 서버

자세한 내용은 8장에서 다룸.

### 1.8.4 터널

**터널의 역할**

- 두 커넥션 사이에서 원본(raw) 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
- 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용됨

**터널 활용 예시**

- 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 HTTP 트래픽만 허용하는 사내 방화벽을 통과시킴

**터널 흐름**

클라이언트 → SSL → 터널 → SSL 커넥션 (443 포트) → 서버 (터널을 통해 HTTP 캐싱 및 HTTP 데이터 전달)

### 1.8.5 에이전트

**에이전트의 개념**

- 사용자 에이전트(혹은 그냥 에이전트)는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램
- 웹 요청을 만드는 애플리케이션은 모두 HTTP 에이전트

**에이전트의 종류**

- 웹 브라우저 외에도 다양한 종류의 사용자 에이전트가 있음
- 사람의 통제 없이 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키고 콘텐츠를 받아오는 자동화된 사용자 에이전트 (보통 '스파이더'나 '로봇'이라고 불림)

**스파이더/로봇의 역할**

- 웹을 돌아다니며 검색엔진의 데이터베이스나 가격비교 로봇을 위한 제품 카탈로그와 같은 유용한 웹 콘텐츠 보관소를 만듦

자세한 내용은 9장에서 다룸.

**[추가] 현대적 예시**

웹 브라우저

- Chrome, Safari, Firefox, Edge 등
- 가장 흔한 사용자 에이전트

모바일 앱의 웹뷰

- 네이버 앱, 카카오톡 앱의 웹페이지 표시 기능
- 인스타그램, 페이스북 앱의 내장 브라우저
- 앱 내에서 HTTP 요청을 보내는 것도 에이전트

검색엔진 크롤러 (스파이더/로봇)

- Googlebot (구글)
- 네이버봇, 다음봇
- 웹페이지를 수집해 검색 결과로 제공

API 테스트 도구

- Postman
- curl
- HTTPie
- 개발자가 API를 테스트할 때 사용

자동화된 봇

- 쇼핑몰 가격비교 봇
- 소셜미디어 자동 포스팅 도구
- 뉴스 수집 봇

음성 비서/스마트 디바이스

- Google Assistant, Siri, 빅스비
- 웹 정보를 가져와 답변할 때도 HTTP 요청을 사용

개발 도구

- Node.js의 fetch 또는 axios
- Python의 requests 라이브러리
- 코드에서 HTTP 요청을 보내는 것도 에이전트

**핵심 정리**: HTTP 요청을 만드는 모든 프로그램이 에이전트입니다. 브라우저든, 앱이든, 봇이든, 코드든 모두 에이전트입니다.

## 2장 URL과 리소스 - 요약

### 2장 개관

**인터넷의 리소스 식별**

- 인터넷을 거대한 도시로 비유하면, 도시의 자원(볼거리, 서비스)을 지칭하는 표준 작명 프로토콜이 필요함
- 길거리 주소, 전화번호, ISBN, 버스 노선 번호, 은행 계좌 번호, 사회 보장 번호 등과 같은 표준화된 이름의 중요성

**URL (Uniform Resource Locator)**

- 인터넷 리소스를 가리키는 표준 이름
- 리소스가 어디에 있고 어떻게 접근할 수 있는지 알려줌

### 2.1 인터넷의 리소스 탐색하기

**URL의 역할**

- 브라우저가 정보를 찾는 데 필요한 리소스의 위치를 가리킴
- 사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하며 공유할 수 있게 함

**프로토콜**

- URL을 통해 HTTP 및 다른 프로토콜을 통해 리소스에 접근할 수 있음
- 사용자가 URL을 입력하면 브라우저가 적절한 프로토콜을 사용하여 메시지를 전송함

**URI와 URL/URN**

- URL은 통합 자원 식별자(URI)의 부분집합
- URI는 URL과 URN으로 구성
  - **URN**: 리소스의 위치와 상관없이 이름만으로 식별
  - **URL**: 리소스의 위치를 설명하여 식별

**용어 사용**

- HTTP 명세에서는 URI를 일반화된 개념으로 사용
- 실제 HTTP 애플리케이션에서는 URL을 URI의 한 부분으로 취급
- 이 책에서는 URI와 URL을 번갈아 사용하지만 대부분 URL을 가리킴

**URL 예시 분석**

```
http://www.joes-hardware.com/seasonal/index-fall.html
```

- `http`: URL의 **스킴** (클라이언트가 리소스에 어떻게 접근하는지)
- `www.joes-hardware.com`: **서버의 위치** (리소스가 어디에 호스팅되어 있는지)
- `/seasonal/index-fall.html`: **리소스의 경로** (서버에 존재하는 로컬 리소스 중 요청받은 리소스가 무엇인지)

**다양한 프로토콜 예시**

- `mailto:president@whitehouse.gov`: 이메일 주소
- `ftp://ftp.lots-o-books.com/pub/complete-price-list.xls`: FTP 서버의 파일
- `rtsp://www.joes-hardware.com:554/interview/cto_video`: 스트리밍 비디오 서버의 영화

**URL의 일관성**

- URL은 인터넷상의 어떤 리소스든지 가리킬 수 있음
- 대부분의 URL은 '스킴://서버위치/경로'와 같은 동일한 구조를 따름
- 모든 사람이 같은 방식으로 리소스를 찾을 수 있도록 단일한 작명 규칙을 가짐

### 2.1.1 URL이 있기 전 암흑의 시대

**URL이 없던 시절의 문제**

- 웹과 URL이 있기 전에는 사람들이 네트워크상의 데이터에 접근하기 위해 애플리케이션마다 다른 분류 방식을 사용
- 이는 비효율적이고 복잡함

**복잡했던 파일 공유 예시**

- FTP 접속, 익명 로그인, 비밀번호 입력
- 디렉터리 이동, 바이너리 형식 전환, 다운로드 등 복잡한 과정 필요

**URL의 현대적 이점**

- 오늘날 브라우저들은 이러한 기능들을 하나의 편리한 패키지에 담아놓음
- URL을 사용하면 애플리케이션들이 하나의 인터페이스를 통해 일관된 방식으로 많은 리소스에 접근할 수 있음
- 복잡한 설명 대신 "ftp://ftp.lots-o-books.com/pub/complete-catalog.xls를 열어봐"라고 말하면 됨

**사용자 경험 개선**

- URL은 애플리케이션이 리소스에 접근하는 방법을 제공
- 많은 사용자는 브라우저가 리소스를 가져오는 데 사용되는 프로토콜이나 접근 방식을 알 필요가 없음
- 웹 브라우저를 사용하면 뉴스 리더, FTP 클라이언트, 전자메일 프로그램 없이도
  - 인터넷 뉴스를 읽고
  - FTP 파일에 접근하고
  - 이메일을 보내고 받을 수 있게 되어 온라인 세상을 단순화시킴

**결론**

- URL은 사용자와 브라우저에게 정보 검색에 필요한 모든 것을 제공
- 원하는 리소스가 어디에 위치하고 어떻게 가져오는지 정의

### 2.2 URL 문법

**URL의 구조**

- URL은 여러 컴포넌트로 구성되어 리소스의 위치와 접근 방법을 명확히 지정함
- 스킴에 따라 URL 문법이 달라질 수 있지만, 대부분의 URL은 일반적인 문법을 따름

**일반적인 URL 문법**

```
<scheme>://<username>:<password>@<host>:<port>/<path>;<parameters>?<query>#<fragment>
```

**URL 컴포넌트 구성 요소**

| 컴포넌트   | 설명                                               | 기본값        |
| ---------- | -------------------------------------------------- | ------------- |
| scheme     | 리소스에 접근하는 데 사용할 프로토콜               | 없음          |
| user       | 리소스에 접근하는 데 필요한 사용자 이름            | anonymous     |
| password   | 사용자의 비밀번호                                  | <이메일>      |
| host       | 서버의 호스트 명이나 IP 주소                       | 없음          |
| port       | 서버가 접속을 기다리는 네트워크 포트               | 스킴별 기본값 |
| path       | 서버 내 리소스의 경로                              | 없음          |
| parameters | 특정 스킴에서 리소스에 접근하는 데 필요한 파라미터 | 없음          |
| query      | 게이트웨이 애플리케이션에 전달할 추가 파라미터     | 없음          |
| fragment   | 리소스의 일부를 가리키는 이름                      | 없음          |

**URL 예시 분석**

```
http://www.joes-hardware.com:80/index.html
```

- `http`: 스킴
- `www.joes-hardware.com`: 호스트
- `80`: 포트
- `/index.html`: 경로

**대부분의 URL은 모든 컴포넌트를 사용하지 않음**

- 가장 중요한 컴포넌트: 스킴, 호스트, 경로

### 2.2.1 스킴: 사용할 프로토콜

**스킴의 역할**

- 애플리케이션에게 어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려줌
- 스킴 이름은 대소문자를 구분하지 않음

**일반적인 스킴 예시**

- `http`: HTTP 프로토콜
- `https`: 안전한 HTTP 프로토콜
- `ftp`: FTP 프로토콜
- `mailto`: 이메일 프로토콜

### 2.2.2 호스트와 포트

**호스트 (Host)**

- 서버 머신을 식별함
- 호스트 명이나 IP 주소로 표현됨

**포트 (Port)**

- 서버가 접속을 기다리는 네트워크 포트를 나타냄
- HTTP는 TCP를 사용하며 기본 포트는 80

**예시**

- `http://www.joes-hardware.com:80/index.html` (호스트 명 사용)
- `http://161.58.228.45:80/index.html` (IP 주소 사용)

→ 두 URL은 같은 리소스를 가리킴

### 2.2.3 사용자 이름과 비밀번호

**역할**

- 많은 서버가 자신이 가지고 있는 리소스에 접근할 때 사용자 이름과 비밀번호를 요구함
- FTP 서버가 대표적인 예시

**FTP URL 예시**

- `ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu`
- `ftp://ftp.prep.ai.mit.edu/pub/gnu` (사용자 이름과 비밀번호 생략 시)
  - 사용자 이름: `anonymous` (기본값)
  - 비밀번호: 브라우저마다 다르게 처리

**사용자 이름과 비밀번호 생략 시**

- 기본값이 사용됨 (예: FTP의 경우 anonymous)
- 브라우저마다 비밀번호 처리 방식이 다를 수 있음

### 2.2.4 경로 (Path)

**경로의 역할**

- 리소스가 서버의 어디에 있는지 알려줌
- 계층적 파일 시스템 경로와 유사한 구조를 가짐

**경로 구조**

- `/` 문자를 기준으로 경로 조각으로 나뉨
- 각 경로 조각은 자체 파라미터를 가질 수 있음

**예시**

```
http://www.joes-hardware.com:80/seasonal/index-fall.html
```

- `/seasonal/index-fall.html`: 경로

### 2.2.5 파라미터 (Parameters)

**파라미터의 필요성**

- 호스트 및 경로 정보만으로는 리소스를 찾기 부족할 때
- 프로토콜이 추가 정보를 요구할 수 있음

**파라미터의 역할**

- 애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 전달함

**형식**

- 이름/값 쌍의 리스트로 구성
- URL 나머지 부분과 `;` 문자로 구분

**예시 1: FTP 프로토콜**

```
ftp://prep.ai.mit.edu/pub/gnu;type=d
```

- `type=d`: 파라미터 (FTP에서 바이너리 모드)

**예시 2: 경로 조각별 파라미터**

```
http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true
```

- `hammers` 경로 조각은 `sale=false` 파라미터를 가짐
- `index.html` 경로 조각은 `graphics=true` 파라미터를 가짐

### 2.2.6 질의 문자열 (Query String)

**질의 문자열의 역할**

- 데이터베이스 같은 서비스에서 요청받을 리소스 형식의 범위를 좁히기 위해 사용

**구조**

- URL의 물음표(`?`) 우측에 있는 값들을 '질의 컴포넌트'라고 부름

**전달 방식**

- 게이트웨이 애플리케이션으로 경로 컴포넌트와 함께 전달됨
- 게이트웨이는 다른 애플리케이션에 접근할 때 거치는 통로 역할

**일반적인 형식**

- `&`로 나뉜 '이름=값' 쌍 형태의 질의 문자열을 선호함

**예시**

```
http://www.joes-hardware.com/inventory-check.cgi?item=12731&color=blue
```

- `item=12731`과 `color=blue` 두 개의 질의 컴포넌트가 존재함

**질의 컴포넌트 흐름**

```
클라이언트 --(인터넷)--> 서버 --(item=12731&color=blue)--> 재고 확인 게이트웨이
```

- 클라이언트가 인터넷을 통해 서버로 질의 컴포넌트를 포함한 요청을 보냄
- 서버는 이 질의 컴포넌트를 재고 확인 게이트웨이 애플리케이션으로 전달하여 특정 상품의 재고를 확인함

**[추가] 파라미터 vs 질의 문자열의 차이**

| 구분          | 파라미터 (`;`)                          | 질의 문자열 (`?`)                   |
| ------------- | --------------------------------------- | ----------------------------------- |
| 용도          | 프로토콜 레벨에서 리소스 접근 방식 지정 | 애플리케이션 레벨에서 리소스 필터링 |
| 경로와의 관계 | 경로의 일부로 여겨짐                    | 경로와 분리된 별도 컴포넌트         |
| 사용 주체     | 프로토콜 자체 (예: FTP의 type=d)        | 애플리케이션 (예: 검색, 필터링)     |
| 현대적 사용   | 거의 사용되지 않음                      | 매우 널리 사용됨                    |

**현실적으로는 질의 문자열(`?`)이 표준**

- 현대 웹에서는 세미콜론(`;`) 파라미터는 거의 사용되지 않음
- 대부분의 웹 프레임워크와 브라우저가 질의 문자열(`?`)만 지원
- 파라미터는 HTTP 표준에 정의되어 있지만 실제로는 역사적 이유로 남아있는 기능
- 질의 문자열이 더 직관적이고 널리 지원되며, 웹 개발자들이 익숙한 방식
- [2014 W3C 권고안](https://www.w3.org/TR/2014/REC-html5-20141028/forms.html#url-encoded-form-data)에서 `&` 를 사용하도록 권고 (?)
  `Let strings be the result of strictly splitting the string payload on U+0026 AMPERSAND characters (&).`
  <img src="./images/battle.png" />

`이걸로 싸우고 있음`

- [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-3.3)에서는 세미콜론(`;`) 파라미터가 허용된다는 내용이 있음
  `For example, the semicolon (";") and equals ("=") reserved characters are often used to delimit parameters and parameter values applicable to
that segment.`

**실제 사용 예시**

```
❌ 이제는 안 쓰는 방식: /hammers;sale=false/index.html
✅ 널리 쓰는 방식: /hammers?idx=1&color=blue
```

### 2.2.7 프래그먼트 (Fragment)

**프래그먼트의 역할**

- HTML과 같은 리소스 형식에서 특정 부분(절, 이미지 등)을 가리킴

**구조**

- URL의 오른쪽에 `#` 문자 다음에 옴

**예시**

```
http://www.joes-hardware.com/tools.html#drills
```

- `drills`는 `/tools.html` 웹페이지의 특정 부분을 가리킴

**서버 처리**

- HTTP 서버는 일반적으로 객체 전체를 다루므로, 클라이언트는 프래그먼트를 서버에 전달하지 않음

**클라이언트 처리**

1. 사용자가 `http://www.joes-hardware.com/tools.html#drills` 링크를 선택함 (프래그먼트는 서버로 보내지 않음)
2. 브라우저는 `http://www.joes-hardware.com/tools.html`을 요청함
3. 서버는 전체 HTML 페이지를 반환함
4. 브라우저가 전체 리소스를 내려받은 후, 프래그먼트 식별자를 사용하여 사용자가 보고자 하는 리소스의 일부를 보여줌
5. 브라우저는 'drills' 프래그먼트로 시작하는 HTML 페이지를 보여줌 (해당 위치로 스크롤)

**핵심 포인트**

- 서버는 객체를 전체 단위로만 전송하기 때문에 URL 프래그먼트는 클라이언트에서만 사용됨
