## 3장 HTTP 메시지

- 메시지가 어떻게 흘러가는가?
- HTTP 메시지의 세 부분 (시작줄, 헤더, 개체 본문)
- 요청과 응답 메세지의 차이
- 요청 메시지가 지원하는 여러 상태 코드들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

### 3.1 메세지의 흐름

HTTP 메시지는 데이터 블록들이며 클라이언트, 서버, 프락시 사이를 흐른다.

HTTP 메시지 흐름에 따라 `인바운드`, `아웃바운드`, `업스트림`, `다운스트림` 으로 나눌 수 있다.

- 인바운드 - 메시지가 원 서버로 향하는 것
- 아웃바운드 - 모든 처리가 끝난 후 서버에서 클라이언트로 돌아오는 것
- 메시지 종류에 상관 없이 모든 메시지는 다운스트림으로 흐른다.

### 3.2 메시지의 각 부분

메시지는 시작줄, 헤더 블록, 본문으로 이루어진다.

- 시작줄 - 어떤 메시지인지 서술
- 헤더블록 - 메시지의 속성
  - ex) Content-type, Content-length
- 본문 - 데이터 혹은 없음

→ 시작줄과 헤더블록은 줄 단위로 분리된 아스키 문자열임

**3.2.1 메시지 문법**

모든 메시지는 요청/응답 메시지로 분류

- 요청 메시지 형식

<메서드> <요청URL> <버전>

<헤더>

<엔터티 본문>

- 응답 메시지 형식

<버전> <상태코드> <사유구절>

<헤더>

<엔터티 본문>

**메서드** : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작

**요청URL** : 요청 대상 리소스 URL 혹은 URL 경로 구성 요소

**버전** : 이 메시지에서 사용 중인 HTTP 버전 `HTT/<메이저>.<마이너>`

**상태 코드** : 요청 중에 무엇이 일어났는지 설명하는 세자리 숫자

**사유 구절 :** 숫자로 된 상태 코드의 의미를 설명하는 문구

**헤더들** : 이름, 콜론, 선택적 공백, 값, CRLF(빈 줄)가 순서대로 나타나는 0개 이상의 헤더들

**엔터티 본문** : 임의의 데이터 블록

→ 메시지의 요소들을 개행으로만 구분했었구나

**3.2.2 시작줄**

요청 메시지의 시작줄은 무엇을 해야하는지 말해준다.

응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

**메서드**

GET, HEAD, POST, PUT, TRACE, OPTIONS, DELETE (PATCH는?)

→ PATCH는 확장 메서드가 아니라, RFC 5789로 정식 표준화된 HTTP 메서드 (부분 업데이트를 위함)

**버전 번호**

HTTP로 대화하는 애플리케이션들에게 버전 정보를 알려줘서 대화 능력과 메시지 형식의 단서를 제공해주기 위함

버전 번호는 메시지를 보낸 주체가 `지원하는 가장 높은 HTTP 버전`을 가리킨다.

버전 번호는 분수로 다루어지지 않음. HTTP/2.22 > HTTP/2.3

**3.2.3. 헤더**

**헤더 분류**

HTTP 헤더 명세는 여러 헤더 필드를 정의하고 자유롭게 자신만의 헤더를 만들어낼 수 있다.

**일반헤더** - 요청과 응답 양쪽 모두 나타날 수 있음

**요청 헤더** - 요청에 대한 부가 정보 제공

**응답 헤더** - 응답에 대한 부가 정보 제공

**Entity 헤더** - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술

**확장 헤더** - 명세에 정의되지 않은 새로운 헤더

→ 헤더의 필드 값을 여러 줄로 쓰려면 추가 줄 앞에 최소 하나의 스페이스 혹은 탭 문자가 와야함

**3.2.4 엔터티 본문**

이미지, 비디오, HTML 문서, 소프트웨어 어플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어나를 수 있다.

### 3.3 메서드

**3.3.1 안전한 메서드 (Safe Method)**

HTTP 요청의 결과로 서버에 어떤 작용도 없는 메서드 ex) GET, HEAD

**HEAD** - 서버에서 어떤 문서에 대해 헤더만 가져온다.

- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)을 알아낼 수 있음
- 응답의 상태 코드로 개체가 존재하는지 확인할 수 있음
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있음
- 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야함
- 실무 예시
  1. **캐시 검증**
     - 브라우저/프록시가 Last-Modified, ETag만 확인해 변경 여부 체크.
  2. **파일 용량 확인**
     - 다운로드 시작 전 Content-Length 확인해 대략적 비용 계산.
  3. **가용성 헬스체크**
     - CDN, 로드밸런서가 콘텐츠 없이 “살아있나” 확인할 때.

**TRACE** - 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.

- 목적지 서버에서 루프백 진단을 시작하여 마지막 단계의 서버가 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려줌
- 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가며 자신이 보낸 메시지가 망가졌거나 수정되었는지, 어떻게 변경되었는지 확인할 수 있음
- TRACE는 다른 메서드들이 일관된 경로를 거쳐간다고 가정하는 문제가 있다.
- 실무예시
  1. **중간 프록시 디버그**
     - 헤더가 사라졌는지, 변조됐는지 추적.
  2. **내부 네트워크 라우팅 이슈 분석**
     - 사내 게이트웨이가 요청을 오염시키는지 확인할 때.
  3. **(현실적 주의) 실서비스에서는 보통 비활성화**
     - XSS/정보 노출 우려 때문에 대부분 서버에서 막아둔다.

**OPTIONS** - 서버가 어떤 메서드를 수행할 수 있는지 확인한다.

- 실무예시
  1. **CORS Preflight**
     - 브라우저가 Access-Control-Allow-\* 헤더 검증.
     - 가장 흔한 실무 시나리오.
  2. **API Gateway 메서드 체크**
     - API 문서 없이도 허용 메서드 자동 파악.
  3. **서버 기능 탐지**
     - 자동화된 클라이언트가 엔드포인트 capability 사전 확보.

### 3.4 상태 코드

100-199 : 정보

- 100 Continue

  - 요청 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지 요청을 계속 이어 보내야함, 이후 서버는 반드시 요청을 받아 응답해야한다.
  - 사례 : S3 같은 스토리지에 대형 업로드할 때

    - 예시

      1. 클라이언트가 500MB 파일 업로드 요청을 준비한다.
      2. 바로 보내면 네트워크 비용이 크고, 서버가 거부하면 손해다.
      3. 그래서 클라이언트는 먼저 헤더만 보낸다.

         ```diff
         Expect: 100-continue
         ```

      4. 서버는 조건을 확인한다. 예:
         - 인증 문제 없는지
         - 업로드 가능한지
         - 용량 정책을 초과하는지
      5. OK라면 서버는 이렇게 응답

         ```diff
         HTTP/1.1 100 Continue
         ```

      6. 이제 클라이언트는 **진짜 바디(500MB)**를 전송한다.

200-299 : 성공

202 - 요청은 받아들여졌으나 아직 동작을 수행하지 않음. 서버는 요청 처리가 언제 완료될 것인지 가급적 포함할 것

203 → 그래서 브라우저에서 캐시된 내용들은 203

300-399: 리다이렉션

400-499: 클라이언트 에러

500-599: 서버에러

### 3.5 헤더

일반 헤더 - 클라이언트와 서버 양쪽 모두 사용, 다양한 목적으로 사용 ex) 메시지 생성 일시

요청 헤더 - 서버에게 클라이언트가 받고자 하는 데이터 타입이 무엇인지와 같은 부가 정보를 제공 ex) Accept: _/_

- Accept 관련 헤더
- 조건부 요청 헤더
- 요청 보안 헤더
- 프락시 요청 헤더

응답 헤더 - 클라이언트에게 정보를 제공하기 위한 헤더 ex) Server: Tiki-Hut/1.0

- 협상헤더
- 응답 보안헤더

엔터티 헤더 - 엔터티 본문에 대한 헤더, ex) Content-type: text/html; charset=iso-latin-1

- 콘텐츠 헤더
- 엔터티 캐싱 헤더

확장 헤더 - HTTP 명세에는 추가되지 않은 비표준 헤더

## 4장 커넥션 관리

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리르 위해 따라야 할 규칙들

### 4.1 TCP 커넥션

HTTP통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.

4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- TCP 커넥션 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다.

  4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송한다.

TCP는 IP 패킷(혹은 IP 데이터그램)이락고 불리는 작은 조각을 통해 데이터를 전송한다.

TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아 인터넷을 통해 데이터를 전달한다.

IP 패킷 구성

- IP 패킷 헤더(보통 20바이트)
- TCP 세그먼트 헤더(보통 20바이트)
- TCP 데이터 조각(0 혹은 그 이상의 바이트)

  4.1.3 TCP 커넥션 유지하기

컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. 포트 번호를 통해서 이런 여러 개의 커넥션을 유지한다.

포트 번호는 내선전화와 같다. IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결된다.

TCP 커넥션은 <발신지 IP 주소, 발신지 포트, 수신지 IP주소, 수신지 포트>로 식별한다.

4.1.4 TCP 소켓 프로그래밍

운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 소켓 API로 제공한다.

소켓 API로 TCP종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

TCP API는 기본적인 네트워크 프르토콜의 핸드셰이킹, TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.

### 4.2 TCP의 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

4.2.1 HTTP 트랜잭션 지연

대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생

HTTP 트랜잭션 지연 원인

1. URI를 DNS인프라로 IP주소로 변환
2. TCP 요청, 허가 응답 회신 대기 시간
3. 커넥션 후 HTTP 요청을 TCP 파이프로 전송, 서버에서 처리하는데까지 소요 시간
4. 웹 서버가 HTTP 응답을 보내는 시간

### 4.3 HTTP 커넥션 관리

4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 순차적으로 HTTP 트랜잭션 처리가 일어나면 커넥션의 맺고 끊음도 여러번 일어남 여러개의 이미지를 받아오는 경우 하나씩 렌더링이될 것임
- 이는 안좋은 사용자 경험으로 이어질 수 있음
- HTTP 커넥션 성능 향상 최신 기술 - 병렬 커넥션 - 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청 - 지속 커넥션 - 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용 - 파이프라인 커넥션 - 공유 TCP 커넥션을 통한 병렬 HTTP 요청 - 다중 커넥션 - 요청과 응답들에 대한 중재(실험적인 기술)

  4.4 병렬 커넥션

HTTP 클라이언트가 여러 개의 커넥션을 맺음으로써 어려 개의 HTTP 트랜잭션을 병려로 처리할 수 있게 한다.

4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.

- 각 커넥션의 지연 시간을 겹치게 하면 총 지연시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 내려받는 데에 남은 대역폭을 사용할 수 있다.

  4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.

- 클라이언트의 네트워크 대역폭이 좁을 때는 대부분의 시간을 데이터를 전송하는 데만 쓸 것이다. 여러 개의 객체를 병렬로 내려받는 경우, 이 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없다.
  → 대역폭이 좁을 때 병렬커넥션의 장점이 없다.
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.
- 많은 사용자가 동시에 다수의 커넥션을 맺고있다면 서버에 부하가오기 때문에 브라우저는 병렬 커넥션을 사용하긴 하지만 적은 수(대부분 6-8개)의 커넥션만 허용한다.
- 서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우 임의로 끊어버릴 수 있다.

  4.4.3 병렬 커넥션은 더 빠르게 ‘느껴질 수’있다.

- 병렬커넥션이 순차커넥션 보다 더 빠르게 리소스를 내려받는 것은 아니지만, 사용자의 입장에서 화면에 여러 개의 객체가 동시에 보이기 때문에 더 빠르게 느낄 수 있다.

  4.5 지속 커넥션

- 웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺는다. 특정 서버에 지속적으로 요청을 하는 속성을 지역성이라고 부른다.
- TCP 커넥션을 유지하여 앞으로 있을 HTTP요청에 재사용할 수 있다.
- 처리 완료된 이후에도 계속 TCP 연결을 유지하는 것을 지속커넥션이라고한다.

  4.5.1 지속 커넥션 vs 병렬 커넥션

- 병렬커넥션의 단점
  - 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요
  - 각 새로운 커넥션은 TCP 느린 시작 때문에 성능 저하
  - 실제로 연결할 수 있는 병렬 커넥션의 수에 제한
- 지속커넥션의 장점
  - 커넥션을 맺기 위한 사전 작업과 지연 감소
  - 튜닝된 커넥션(패킷을 수차례 성공 전송하면 한 번에 다수의 패킷을 전송할 수 있는 권한을 얻음)
- 지속커넥션의 단점
  - 잘못 관리할 경우 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 됨
  - → 로컬 리소스, 원격 클라이언트, 서버 리소스 불필요한 소모
- 병렬 + 지속 커넥션

  4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

- keep-alive 커넥션은 지속 커넥션을 지원하기 위해 확장 됨

  4.5.3 Keep-Alive 동작

- HTTP/1.1의 명세부터 빠졌지만 아직도 브라우저와 서버 간에 keep-alive 핸드셰이크가 널리 사용되어 HTTP 애플리케이션은 이것을 처리할 수 있게 개발해야함
- 클라이언트 요청 시 : 헤더에 Connection:Keep-Alive 포함
- 서버 응답 시 : 같은 헤더 포함 (그 다음 요청도 이 커넥션을 통하고자한다면)

  4.5.4 Keep-Alive 옵션

- Keep-Alive 헤더는 커넥션을 유지하길 원하는 요청일 뿐 서버에서는 이를 무시할 수 있음
- 커넥션을 끊을 수도 있고 해당 커넥션에서 처리되는 트랜젝션 수를 제한할 수도 있음
- timeout, max파라미터가 있지만 이대로 동작한다는 보장은 없다.

  4.5.5 Keep-Alive 커넥션 제한과 규칙

- 클라이언트는 keep-alive 커넥션을 사용하기 위해 Connection:Keep-Alive 요청 헤더를 보내야함
- 커넥션을 계속 유지하려면 모든 메세지에 해당 해더를 포함해야함
- 클라이언트에서는 응답헤더에 Connection:Keep-Alive가 없으면 응답 후 커넥션을 끊은 것임을 알 수 있음
- 정확한 Content-Length
- 프락시와 게이트웨이는 Connection 헤더 규칙을 철저히 지켜야함

  4.5.6 Keep-Alie와 멍청한 프락시

- 프락시는 Connection:Keep-Alive를 이해하지 못하여 요청과 응답헤더를 그대로 전달한 후 서버가 커넥션을 끊기를 기다림 → 하지만 서버는 커넥션이 지속되길 원하는 줄 알고 있어 유지함, 프록시만 커넥션이 끊어지길 기다리고 있음
- 이후 클라이언트가 커넥션이 유지되고 있는 프락시에 요청을 보내지만 프락시는 같은 커넥션 상에서 다른 요청이 오는 경우를 예상하지 못하기 때문에, 그 요청은 무시되고 브라우저는 아무런 응답 없이 로드 중이라는 표시만 나옴
- 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때 까지 기다림

- 이런 잘못된 통신을 피하려면 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안됨.

  4.5.7 Proxy-Connection 살펴보기

- 클라이언트의 요청이 중개서버를 통해 이어지는 경우 모든 헤더를 무조건 전달하는 문제를 해결하기 위해 Proxy-Connection이라는 헤더를 사용
- Proxy-Connection은 프락시를 별도로 설정할 수 있는 현대의 브라우저들에서 지원

  4.5.8 HTTP/1.1의 지속 커넥션

- HTTP/1.1에서는 Keep-alive 설정을 하지 않아도 기본적으로 지속커넥션으로 활성화되어있다.
- Connection: close로 헤더를 명시해야 커넥션을 끊을 수 있음
- → 하지만 이걸 보내지 않는다는 것이 커넥션을 영원히 유지하겠다는 말은 아님

  4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 Connection:close 헤더를 포함하면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없다.
- 커넥션에 있는 모든 메세지가 자신의 길이 정보를 정확히 가지고 있을 때만 커넥셔능ㄹ 지속시킬 수 있음
- 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면, 요청을 반복해서 보내도 문제가 없는 경우에는 요청을 다시 보낼 준비가 되어있어야 한다
- 하나의 사용자 클라이언트는 서버의 과부하를 방지하기 위해 넉넉잡아 두 개의 지속 커넥션만을 유지해야한다.

  4.6 파이프라인 커넥션

- HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝할 수 있다. 이는 keep-alive 커넥션의 성능을 더 높여준다.
- HTTP클라이언트는 커넥션이 지속되기 전까지 파이프라인을 이어서는 안된다.
- 응답은 요청 순서와 같게 와야한다.
- 클아이언트 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어있어야한다.
- 클라이언트는 POST와 같이 중복 요청 시 멱등성을 보장하지 못하는 요청은 파이프라인을 통해 보내면 안된다. ⇒ 에러 발생 시 파이프라인을 통한 요청 중 어떤 것들이 서버에서 터리되었는지 클라이언트에서 알 방법이 없다.

  4.7 커넥션 끊기에 대한 미스터리

커넥션관리(특히 언제 어떻게 커넥션을 끊는가)에는 명확한 기준이 없다. 이 이슈는 수많은 개발자가 알고 있는 것보다 더 미묘하며, 그에관한 기술문서도 별로 없다.

4.7.1 ‘마음대로’ 커넥션 끊기

어떤한 HTTP 클라이언트, 서버, 혹은 프락시든 언제든지 TCP 젅송 커넥션을 끊을 수 있다.

4.7.4 우아한 커넥션 끊기

전체 끊기

close()를 호출하면 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는다.

절반 끊기

shutdown()을 호출하면 입력 채널 과 출력 채널 중 한개만 끊거나 둘 다 끊을 수 있다.
