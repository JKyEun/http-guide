# 03. HTTP 메시지

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요처과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨일을 하는가

## 3.1 메시지의 흐름

- HTTP 메시지는 HTTP 어플리케이션 간에 주고받은 데이터의 블록

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

- 인바운드 : 원래의 서버로 이동하는 방향
- 아웃바운드 : 서버에서의 처리가 끝난 다음 사용자 에이전트로의 방향

### 3.1.2 다운 스트림으로 흐르는 메시지

- 흐름의 방향에서 상위의 요소는 업 스트림, 하위의 요소는 다운 스트림

## 3.2 메시지의 각 부분

- 메시지는 시작 줄, 헤더 블록, 본문으로 구성
- 시작 줄 : 이것이 어떤 메시지인지 서술, 캐리지 리턴(HTTP 명세) 또는 개행 문자로 구분
- 헤더 블록 : 속성, 캐리지 리턴(HTTP 명세) 또는 개행 문자로 구분
- 본문 : 데이터, 비어 있거나 텍스트나 이진 데이터 포함 가능

### 3.2.1 메시지 문법

- 요청 메시지는 웹 서버에 어떤 동작을 요구

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

- 응답 메시지를 요청 메시지의 결과를 응답

```
<버전> <상태 코드> <사유 구정>
<헤더>

<엔터티 본문>
```

![img.png](images/03_http_msg_01.png)

#### 메서드

- 클라이언트 측에서 서버가 리로스에 대해 수행해주길 바라는 동작, GET / HEAD / POST 등

#### 요청 URL

- 요청 되상이 되는 리소스를 지칭하는 완전한 URL

#### 버전

- 메세지에서 사용 중인 HTTP 의 버전, `HTTP/<메이저 버전>.<마이너 버전>`

#### 상태 코드

- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자

#### 사유 구절

- 숫자 상태 코드의 의미를 사람이 이해할 수 있도록 설명해 주는 도구, 프로토콜의 규약에는 상관 없이 사람의 이해를 위해서만 사용

#### 헤더들

- 추후 자세히 다룰 예정

#### 엔터티 본문

- 임의 데이터 블록을 포함 하거니 빈 상태(CRLF)로 전달
- 엔터티 본문이 없어도 헤더 다음에 CRLF 가 있어야 하는 것이 규약

### 3.2.2 시작 줄

##### 요청 줄

- 메서드 / 요청 URL / HTTP 버전이 포함 되며, 공백으로 구분
- `ex) GET /test/hi-there.txt HTTP/1.1`

#### 응답 줄

- HTTP 버전 / 상태 코드 / 사유 구절
- `ex) HTTP/1.0 200 OK`

#### 메서드

- 서버에 무엇을 해야하는지 알려주는 규약
- 단, 서버 별로 구현된 메서드가 다를 수 있으니 주의 필요

| 메서드  | 설명                                                   | 메시지 본문 |
| :------ | :----------------------------------------------------- | :---------: |
| GET     | 서버에서 어떤 문서를 가져온다                          |      X      |
| HEAD    | 서버에서 어떤 문서에 대한 헤더만 가져온다              |      X      |
| POST    | 서버가 처리해야할 데이터를 보낸다                      |      O      |
| PUT     | 서버에 요청 메시지의 본문을 저장한다                   |      O      |
| TRACE   | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 |      X      |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다         |      X      |
| DELETE  | 서버에서 문서를 제거한다                               |      X      |

#### 상태 코드

- 클라이언트에게 서버에서 무엇이 일어났는지 알려주는 3자리 코드

| 전체 범위 | 정의된 범위 |      분류       |
| :-------: | :---------: | :-------------: |
| 100 - 199 |  100 - 101  |      정보       |
| 200 - 299 |  200 - 206  |      성공       |
| 300 - 399 |  300 - 305  |   리다이렉션    |
| 400 - 499 |  400 - 415  | 클라이언트 애러 |
| 500 - 599 |  500 - 505  |    서버 에러    |

#### 사유 구절

- 상태 코드를 사람이 이해할 수 있도록 설명한 버전

#### 버전 번호

- HTTP 프로토콜의 버전을 알려주는 역할
- 한 쪽, 버전이 낮을 경우 낮은 버전의 기능을 사용해서만 통신

### 3.2.3 헤더

- 요청과 응답 메시지에 추가 정보를 더하는, 이름 / 값의 목록

#### 헤더 분류

- 일반 헤더 : 요청과 응답 양쪽에 사용 가능
- 요청 헤더 : 요청에 대한 부가 정보 제공
- 응답 헤더 : 응답에 대한 부가 정보 제공
- Entity 헤더 : 본문 크기와 콘텐츠, 혹은 리소스 자체를 서술
- 확장 헤더 : 명세에 정의되지 않은 새로운 헤더
  - `ex) Date Tue, 3 Oct 1997 02:16:03 GMT`
  - `Content-length: 15040`

#### 헤더를 여러 줄로 나누기

- 헤더를 나눌 때에는 여러 줄로 나눌 때, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 필요

### 3.2.4 엔티티 본문

- HTTP 메시지의 세번째 부분으로 선택적으로 실제 데이터를 담는 영역

### 3.2.5 버전 0.9 버전 메시지

![img.png](images/03_http_msg_02.png)

- 요청과 응답 모두 헤더가 없으며, 요청은 버전 표기가 없고 응답은 상태 코드 및 구절이 없다

## 3.3 메서드

### 3.3.1 안전한 메서드

- GET, HEAD 메서드는 실제적으로 서버에는 아무런 변화를 일으키지 않으므로 안전한 메서드로 구분
- 단, 실제 서버에 작용을 일으키지 않는다고 완전히 보장은 X → 해당 메서드의 목적성을 사용자에게 알리는 용도

### 3.3.2 GET

- 서버의 리소스를 요청하기 위해 사용

### 3.3.3 HEAD

- GET 과 유사하나 헤더만 응답으로 반환
- 리소스를 가져오지 않고 리소스의 타입, 개체의 존재 여부, 리소스 변경 여부 확인 가능

### 3.3.4 PUT

- 요청 본문을 바탕으로 서버에 리소스가 없으면 새로 작성, 있으면 기존의 리소스를 수정

### 3.3.5 POST

- 서버에 입력 데이터를 전송하기 위해 설계(Form)

### 3.3.6 TRACE

- 서버의 응답의 본문에 클라이언트의 요청을 그대로 반환, 이를 통해 통신 과정에서 요청 메시지가 망가졌는지 확인 가능
- 클라이언트와 서버 사이의 `루프백(loopback)` 진단을 위해 사용

> 최근에는 XST(Cross-Site Tracing) 위협으로 인해 대부분의 서버에서 비활성화 </br>
> XSS(Cross-Site Scripting) 을 통해 사용자의 로그인 요청을 TRACE 로 보내게 되면, 사용자의 요청을 서버에서 그대로 돌려주므로 정보 및 헤더에 포함 된 세션 ID 등을 탈취 가능

### 3.3.7 OPTIONS

- 서버에게 지원하는 메서드의 지원 범위를 물어보는 요청 메서드

### 3.3.8 DELETE

- 서버에서 특정 리소스를 삭제하는 것을 요청
- 단, 서버에서 리소스가 삭제되는 것을 보장하는 것은 아님

### 3.3.9 확장 메서드

- HTTP 는 필요에 따라 확장이 가능하여 필요 메서드를 확장하여 사용이 가능하다

> 백엔드 Security 메서드 허용 설정에서 해당 메서드가 HTTP 버전에 따른 enum 과 같이 정의된 타입이 아니라 문자열인 이유

## 3.4 상태 코드

### 3.4.1 100-199: 정보성 상태 코드

- 정보성 상태 코드는 1.1 버전에서 도입

| 상태 코드 |      사유 구절      | 의미                                                                   |
| :-------: | :-----------------: | :--------------------------------------------------------------------- |
|    100    |      Continue       | 요청의 시작이 허용 되었으며, 나머지 요청을 계속 보내야 함              |
|    101    | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열할 것 중 하나로 서버가 프로토콜을 변경 |

#### 클라이언트와 100 Continue

- 클라이언트가 대용량 본문 전송 등을 위해 서버의 상태 확인을 위해 사용
- 요청 헤더에 Expect: 100 Continue 를 담아서 전달하고, 해당 요청을 받은 서버는 상황에 따라 특수한 코드인 100 Continue 응답을 보내거나 요청 거부 응답을 보내야 함
- 프록시 사용 시, 홉 서버가 HTTP 버전이 1.1 이하를 사용하는 경우라면 서버가 가능한 상태이더라도 100 Continue 가 아닌 417 Expectation Failed 로 응답 해야함

### 3.4.2 200-299: 성공 상태 코드

- 요청 성공 시의 상태 코드

| 상태 코드 |   사유 구절 (Reason Phrase)   | 의미                                                                                                                        |
| :-------: | :---------------------------: | :-------------------------------------------------------------------------------------------------------------------------- |
|    200    |              OK               | 요청은 정상, 응답 본문에 요청한 리소스가 포함                                                                               |
|    201    |            Created            | 서버 개체 생성을 위한 `PUT` 요청에 대한 응답, 응답에는 리소스에 대한 Location 헤더와 함께 리소스를 참조할 수 있는 정보 포함 |
|    202    |           Accepted            | 요청은 받아 들여졌으나, 서버는 아직 동작을 수행하지 않았다는 응답. 주로 비동기에 사용                                       |
|    203    | Non-Authoritative Information | 요청은 성공했지만, 응답의 메타 정보가 원본 서버가 아닌 프록시 서버에서 왔을 수 있음을 의미                                  |
|    204    |          No Content           | 요청은 성공적으로 처리되었으나 응답 본문에 돌려줄 내용이 없는 `DELETE` 사용 시 사용. 폼 리프레쉬 등에 사용                  |
|    205    |         Reset Content         | 주로 브라우저를 위해 사용. HTML 의 Form 을 전부 비울 때 사용                                                                |
|    206    |        Partial Content        | 부분 혹은 범위 요청의 성공을 의미, `Range` 헤더를 기반으로 범위 요청의 성공을 의미                                          |

> 책에는 리소스 생성을 PUT 으로 설명 중인데, AI 는 생성은 POST 수정은 POST 로 이야기 하는 부분에 대한 생각은?

### 3.4.3 300-399: 리다이렉션 상태 코드

- 클라이언트가 요청한 리소스에 대해 다른 위치를 사용하라고 알려주거나, 다른 대안 응답을 제공

| 상태 코드 | 사유 구절 (Reason Phrase) | 의미                                                                                                             |
| :-------: | :-----------------------: | :--------------------------------------------------------------------------------------------------------------- |
|    300    |     Multiple Choices      | 요청 된 리소스에 대한 여러 리소의 목록으로 응답 (언어 선택에 케이스 등)                                          |
|    301    |     Moved Permanently     | 리소스가 옮겨진 경우, 현재 리소스가 위치하는 URL 을 헤더에 포함해야 함                                           |
|    302    |           Found           | 301 의 상태코드, 301 에 포함된 옮겨진 리소스의 위치에서 리소스를 찾은 경우.                                      |
|    303    |         See Other         | POST 요청에 대한 응답으로 리소스를 다른 URL(응답 헤더에 포함)에서 GET 으로 메서드를 변경하여 가져와야 함을 의미. |
|    304    |       Not Modified        | 조건부 요청에 대해, 리소스 변화가 없음을 의미                                                                    |
|    305    |         Use Proxy         | 리소스가 반드시 프록시를 통해 접근해야 함을 전달, 프록시의 위치는 응답 헤더에 포함                               |
|    306    |       Switch Proxy        | 현재 사용 X, 306 응답을 통해 사용자에게 악의적인 프록시 서버 위치 전달이 가능                                    |
|    307    |    Temporary Redirect     | 임시적으로 변경 된 리소스의 위치를 응답 헤더에 포함하여 전달                                                     |

> 306 안알랴줌.... ㅋㅋㅋㅋㅋㅋ

### 3.4.4 400-499: 클라이언트 에러 상태 코드

- 클라이언트에서 에러가 발생 했음을 의미

| 상태 코드 |    사유 구절 (Reason Phrase)    | 의미                                                                             |
| :-------: | :-----------------------------: | :------------------------------------------------------------------------------- |
|    400    |           Bad Request           | 클라이언의 잘못된 요청                                                           |
|    401    |          Unauthorized           | 인증 요구 응답                                                                   |
|    402    |        Payment Required         | 현재 사용 X, 미래를 위해 준비                                                    |
|    403    |            Forbidden            | 요청이 서버에 의해 거부 된 이유를 숨기고 싶을 때 사용                            |
|    404    |            Not Found            | 요청한 URL 을 찾을 수 없을 때                                                    |
|    405    |       Method Not Allowed        | 요청한 URL 은 존재하나 지원하지 않는 메서드 요청일 경우                          |
|    406    |         Not Acceptable          | 서버가 클라이언트 요청 헤더에 명시 된 미디어 타입 중 어떤 것도 응답할 수 없을 때 |
|    407    |  Proxy Authentication Required  | 리소스에 대한 인증을 요구하는 프록시 서버를 위해 사용                            |
|    408    |         Request Timeout         | 응답에 오랜 시간이 걸리는 경우 해당 응답을 보내고 연결을 끊을 때 사용            |
|    409    |            Conflict             | 요청이 충돌을 일으킬 수 있을 때 사용                                             |
|    410    |              Gone               | 404와 비슷하나 서버 유지 보수를 위해 일시적으로 제거된 경우에 사용               |
|    411    |         Length Required         | 요청 메세지에 Content-Length 를 요구하는 경우 사용                               |
|    412    |       Precondition Failed       | 조건부 요청(`Expect Header`)에서 하나가 실패한 경우                              |
|    413    |    Request Entity Too Large     | 서버가 처리할 수 있는 크기 이상의 요청 시 응답으로 사용                          |
|    414    |      Request URI Too Long       | 서버가 처리할 수 있는 길이 이상의 URL 요청의 응답                                |
|    415    |     Unsupported Media Type      | 서버가 이해할 수 없는 유형의 데이터 요청 시 사용                                 |
|    416    | Requested Range Not Satisfiable | 리소스의 특정 범위 요청이 잘못된 경우 사용                                       |
|    417    |       Expectation Failed        | Expect 요청 헤더에 포함된 내용을 서버가 처리할 수 없는 경우에 사용               |

> 413 의 경우 GPT 는 Payload Too Large(HTTP/1.1 개정, 2014) 로 써주는 거 보면, Request Entity(HTTP/1.1, 1999) 에 대한 낯설음이 바로 사라지는 군요 <br>

### 3.4.5 500-599: 서버 에러 상태 코드

- 서버 자체에서 에러가 발생한 경우 사용하는 코드

| 상태 코드 | 사유 구절 (Reason Phrase)  | 의미                                                                                                               |
| :-------: | :------------------------: | :----------------------------------------------------------------------------------------------------------------- |
|    500    |   Internal Server Error    | 서버가 요청을 처리 불가능할 때 사용                                                                                |
|    501    |      Not Implemented       | 클라이언트가 서버의 능력을 넘는 요청을 한 경우 사용 (메서드가 지원 되지 않는 경우)                                 |
|    502    |        Bad Gateway         | 프록시 또는 게이트웨이와 같이 응답 연쇄 서버가 실제 서버로 부터 받은 응답을 클라이언트로 전달이 불가능한 경우 사용 |
|    503    |    Service Unavailable     | 서버가 현재는 요청을 처리할 수 없을 때 사용. Retry-After 헤더를 통해 서비스 가능 시간 안내 가능                    |
|    504    |      Gateway Timeout       | 프록시 또는 게이트웨이 서버에서 실제 서버로 부터 응답을 못 받은 경우에 사용                                        |
|    505    | HTTP Version Not Supported | 서버가 지원하지 않는 HTTP 버전일 경우 사용                                                                         |

## 3.5 헤더

- 일반 헤더 / 요청 헤더 / 응답 헤더 / 언터티 해더 / 확장 헤더로 구성

### 3.5.1 일반 헤더 (General Header)

- 메시지의 종류에 상관 없이 기본적인 정보를 제공하는 헤더

|       헤더        | 설명                                                              |
| :---------------: | :---------------------------------------------------------------- |
|    Connection     | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정하기 위해 사용 |
|       Date        | 메시지가 언제 만들어졌는지에 대한 정보                            |
|   MIME-Version    | 발송자가 사용한 MIME 의 버전 정보                                 |
| Transfer-Encoding | 수신자에게 안전한 전송을 위해 적용된 인코딩 정보                  |
|      Upgrade      | 발송자가 업그레이드 하기 원하는 버전 혹은 프로토콜 정보           |
|        Via        | 이 메시지가 어떤 중개자(프록시, 게이트웨이)를 거쳐 왔는지 정보    |

#### 일반 캐시 헤더

- HTTP/1.0 에서 적용 된 헤더로, 매번 서버로 부터 정보를 가져 오는 것이 아니라 로컬 복사본으로 캐시할 수 있도록 하는 헤더

|     헤더      | 설명                                              |
| :-----------: | :------------------------------------------------ |
| Cache-Control | 메시지와 함개 캐시 지시자를 전달하는 용도         |
|    Pragma     | 메시지화 함께 지시자를 전달, 캐시에 국한되지 않음 |

### 3.5.2 요청 헤더

- 요청 메시지에서만 의미를 가지는 헤더

![img.png](images/03_http_msg_03.png)

#### Accept 관련 헤더

- 클라이언트가 서버에게 자신의 선호와 능력을 알려주는 헤더

![img.png](images/03_http_msg_04.png)

#### 조건부 요청 헤더

- 클라이언트가 요청에 제약을 넣기 위해 사용하는 헤더

![img.png](images/03_http_msg_05.png)

#### 요청 보안 헤더

- HTTP 자체에서 요청을 위한 인증요구/응답 체계에서 사용하기 위한 헤더

![img.png](images/03_http_msg_06.png)

#### 프락시 요청 헤더

- 프락시를 위한 헤더

![img.png](images/03_http_msg_07.png)

### 3.5.3 응답 헤더

- 클라이언트에 본문 이외의 부가 정보를 전달하기 위한 헤더

![img.png](images/03_http_msg_08.png)

#### 협상 헤더

- 클라이언트와 서버가 전달 가능한 응답간의 협상을 위해 사용되는 헤더

![img.png](images/03_http_msg_09.png)

#### 응답 보안 헤더

- HTTP 자체에서 요청을 위한 인증요구/응답 체계에서 사용하기 위한 헤더

![img.png](images/03_http_msg_10.png)

### 3.5.4 엔터티 헤더

- 메시지 본문에 대한 광범위한(개체의 타입, 유효한 메서드 등) 정보를 제공

![img.png](images/03_http_msg_11.png)

#### 엔터티 캐싱 헤더

- 엔터티 캐싱에 대한 정보(캐시 사본의 유효 여부 및 기간)를 제공

![img.png](images/03_http_msg_12.png)

# 04. 커넥션 관리

- HTTP 는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프 라인을 활용한 HTTP 의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

## 4.1 TCP 커넥션

- HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화 집합인 TCP/IP 를 통해 이루어 진다
- TCP/IP 커넥션이 수립되면 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달

#### 커넥션 흐름 정리

1. 브라우저가 특정 호스트 명을 호출
2. 브라우저가 해당 호스트 명에 대한 IP 주소를 찾는다
3. 브라우저가 포트 번호(80)를 얻는다
4. 브라우저가 찾은 IP 주소와 포트 번호를 바탕으로 TCP 커넥션을 생성
5. TCP 커넥션 위에서 HTTP 통신을 수행

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션은 몇몇 규칙을 제외하고 TCP 커넥션에 불과, HTTP 의 신뢰성은 TCP 의 신뢰성에 기반

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP 는 IP 패킷(or 데이터그램)이라 불리는 작은 조각으로 데이터를 전송
- HTTP 가 메시지를 전송하고자 할 때, TCP 커넥션을 통해 메시지의 데이터를 순서대로 전달
- TCP 는 세그먼트 단위로 데이터 스트림을 자르고 세그먼트를 IP 패킷이라는 봉투에 담에서 전달

#### IP 패킷의 구성 요소

- IP 패킷 헤더 (보통 20 Byte) : IP 주소, 크기, 기타 플래그
- TCP 세그먼트 헤더 (보통 20 Byte) : TCP 포트 번호(8 Byte), TCP 제어 플래그(2 Byte), 데이터 순서 및 무결성을 위한 검사 데이터(6 Byte), 기타(4 Byte)
- TCP 데이터 조각 (0 ~ 65,535 Byte)

![img.png](images/04_connection_management_01.png)

### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 항상 여러 TCP 커넥션을 포트 번호를 통해서 유지
- TCP 커넥션은 `<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>` 로 식별

| 커넥션 | 발신지 IP 주소 | 발신지 포트 | 목적지 IP 주소 | 목적지 포트 |
| :----- | :------------: | :---------: | :------------: | :---------: |
| A      |  209.1.32.34   |    2034     | 204.62.128.58  |    4133     |

### 4.1.4 TCP 소켓 프로그래밍

- 소켓 API 를 통해 TCP 종단의 데이터 구조를 생성 및 데이터 구조를 연결하여 직접 데이터 스트림을 읽고 쓸 수 있다
- 보통 소켓 API 는 저 수준의 OS 인터페이스로서 HTTP 프로그래머로는 언어에서 제공하는 고수준 API 를 사용, 따라서 TCP 와 IP 의 세부사항을 숨기는 역할을 제공
- `ex) 우리는 fetch 를 쓰지만 실제적으로 해당 기능의 내부에는 소켓 API 가 사용`

## 4.2 TCP 의 성능에 대한 고려

- HTTP 의 트랜잭션은 TCP 위에 성립 되므로, TCP 의 성능에 영향을 받음

### 4.2.1 HTTP 트랙잭션 지연

![img.png](images/04_connection_management_02.png)

- 트랜잭션을 지연 시키는 원인들
  - 방문한 적 없는 URI 접근 시, DNS 에서 IP 주소를 알아내는데 걸리는 시간
  - HTTP 트랜잭션에서 매번 발생하는 TCP 커넥션 요청을 보내고 응답을 회신하는 커넥션 설정 시간
  - 요청 메시지가 물리적 네트워크를 통해 전달되는 시간
  - 서버에서 응답을 처리하는 시간

### 4.2.2 성능 관련 중요 요소

- TCP 커넥션의 핸드셰이크 설정
- 인터넷 혼잡을 제어하기 위한 TCP 의 느린 시작(slow-start)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP 의 편승(piggyback) 확인 응답(acknowledgment)을 위한 확인 응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 새로운 TCP 커넥션을 열 때, 커넥셭을 맺기 위해 연속으로 IP 패킷을 교환하게 되는데 작은 데이터 전송 시 해당 오버헤드로 인한 성능 저하
- 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP 구성에 쓰게 되므로, HTTP 는 이미 존재하는 커넥션을 재활용

![img.png](images/04_connection_management_03.png)

### 4.2.4 확인 응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지 않기 때문에, TCP 는 순번과 데이터 무결성을 위한 체크섬을 사용
- 수신자는 확인 응답을 송신자에게 반환하는 매커니즘을 통해 패킷의 무결성을 파악
- 확인 응답을 따로 송신하는 것이 아니라 데이터 패킷에 편승 시키기 위해, 특정 시간(0.1 ~ 0.2s) 동안 버퍼에 저장하고 데이터 패킷이 발생하면 편승 시키는 확인 응답 지연 알고리즘이 사용
- 이러한 알고리즘과 편승할 데이터 패킷이 없는 케이스가 발생하게되면 지연이 발생

### 4.2.5 TCP 느린 시작(slow start)

- TCP 커넥션은 자체적으로 튜닝되어 처음에는 커넥션의 최대 속도를 제한하고 있다가 데이터가 성공적으로 전송 되면 속도 제한을 높임으로 급작스러운 서버 부하와 혼잡을 방지
- 최초에는 1개의 패킷만 전송한 다음, 확인 응답을 받으면 2개, 2개에 대한 확인 응답을 받으면 4개 까지 튜닝
- 위와 같이 튜닝 된 TCP 커넥션의 속도가 더 빠르므로 존재하는 커넥션을 재활용 하는 것이 유리하다

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- TCP 전송 시에는 약 40바이트 상당의 플래그와 헤더를 보내야하기 때문에 작은 크기의 데이터를 전송할 때마다 통신을하게 되면 네트워크 비효율이 발생
- 네트워크 효율을 위해서 많은 양의 TCP 데이터를 한 개의 덩어리로 합치는 알고리즘을 `네이글(Nagle) 알고리즘`이라고 한다
- 네이글 알고리즘은 세그먼트가 최대 크기(LAN 1,500 바이트 / 인터넷 수백 바이트)가 되지 않으면 전송을 하지 않음. 단, 다른 모든 패킷이 확인 응답을 받은 케이스에서는 최대 크기보다 작은 패킷의 전송을 허락
- 네이글 알고리즘을 사용하는 상황에서 확인 응답 지연이 발생하면 확인 응답에 의한 딜레이 + 패킷을 쌓는 시간이 겹쳐서 큰 비효율이 발생
- 위와 같은 상황 해결을 위해 HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화 하기도 함

### 4.2.7 TIME_WAIT 의 누적과 포트 고갈

- 서버는 커넥션 중복에 의한 패킷 충돌을 방지하기 위해 2MSL(약 2분, Two Maximum Segment Lifetimes)를 적용, 이전 접속 포트와 동일한 커넥션이 생성되어 패킷이 전달되는 상황을 방지
- 단, 서버가 `발신지의 최대 가능 포트 수 (60,000개 가정) / 2MSL (약 120초) = 초당 최대 커넥션 수 (약 500개)` 보다 처리 능력이 뛰어날 경우 포트 고갈 문제가 발생 가능

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP 는 서버 사이에 프락시 서버, 캐시 서버 같은 중개 서버를 허용하며 해당 모든 서버를 거치면서 전달
- 해당 과정에서 다음 메시지를 보낸 다음 끊어져야 할 커넥션은 `Connection: close` 라고 명시 가능
- 이를 사용하여 다음 서버에 특정 헤더 필드를 전달하지 않도록 설정이 가능하며, 홉별(hop-by-hop) 헤더 명을 기술하여 Connection 헤더에 명시 된 내용이 전달 되는 것을 방지

### 4.3.2 순차적인 트랙잭션 처리에 의한 지연

- 하나의 웹 페이지에서 각기 다른 트랜잭션의 발생하고 각각의 트랜잭션이 순차적으로 새로운 커넥션을 필요로 한다면, 커넥션 수립 및 느린 시작 등 다양한 이유에 의한 지연이 발생

![img_1.png](images/04_connection_management_04.png)

- 위와 같은 문제를 해결하기 위해서 `병렬 커넥션 / 지속 커넥션 / 파이프라인 커넥션 / 다중 커넥션` 를 사용

## 4.4 병렬 커넥션

- HTTP 클라이언트가 여러 개의 커넥션을 한번에 맺음으로써 여러개의 트랜잭션을 병렬로 처리하는 방식

![img.png](images/04_connection_management_05.png)

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 커넥션 제한이 없는 가정에서 모든 병렬 커넥션이 정상 작동할 경우 이미지나 리소스를 병렬로 내려받아 커넥션 지연이 겹치게되어 총 지연 시간이 단축되며, 병렬 처리로 인해 전체 처리 시간도 단축 된다

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 네트워크 대역폭이 좁을 때에는 병렬로 받아도 성능상의 장점은 거의 없어짐
- 다수의 커넥션은 메모리를 많이 소모하고, 자체적인 성능 문제도 발생이 가능
- 서버도 다수의 커넥션이 몰리게 되면 과부화로 이어져 서버 성능에도 문제 발생이 가능
- 위와 같은 이유로 브라우저는 실제로 4개 정도의 병렬 커넥션을 사용

> 현 브라우저는 HTTP/1.1 에서는 6개를 사용하며, HTTP/2 이상 환경에서는 1개의 커넥션에 멀티 플렉싱을 사용하여 성능을 획기적으로 개선

### 4.4.4 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 병렬 처리로 인해 사용자에게 체감상 빠르게 느껴질 수 있음

## 4.5 지속 커넥션

- HTTP/1.1 버전 부터는 처리가 완료된 이후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용

> 해당 과정에서 얻을 수 있는 이점은?

### 4.5.1 지속 커넥션 vs 병렬 커넥션

- 병렬 커넥션은 매번 새로운 연결 / 느린 시작 문제 / 커넥션 수의 제한이라는 문제가 존재
- 지속 커넥션은 튜닝된 커넥션 유지 / 커넥션 수를 줄여줌의 장점을 가지지만 관리가 잘 안될 경우 커넥션이 쌓여 클라이언트와 서버에 과부화를 유발
- 지속 커넥션은 2가지의 타입이 존재 하며 HTTP/1.0+ 의 `keep-alive` 커넥션과 HTTP/1.1 의 `지속` 커넥션이 존재

### 4.5.2 HTTP/1.0+ 의 Keep-Alive 커넥션

- HTTP/1.0 시절 지속 커넥션을 지원하기 위해 `keep-alive` 커넥션을 지원. 설계상의 문제는 HTTP/1.1 에서 수정
- 지속 커넥션을 사용하여 트랙잭션 별로 커넥션 수립에 필요한 시간 및 느린 시작등의 문제를 해결 가능

![img.png](images/04_connection_management_06.png)

### 4.5.3 Keep-Alive 동작

- HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션 유지를 위해 `Connection: Keep-Alive` 헤더를 포함하고 서버 역시 응답에 `Connection: Keep-Alive` 를 포함. `Connection: Keep-Alive` 헤더가 포함 시 커넥션을 유지하며 아닐 경우 커넥션을 종료

### 4.5.4 Keep-Alive 옵션

- `Keep-Alive` 헤더는 커넥션을 유지하기 바라는 요청일 뿐, 서버의 선택에 따라 결정
- `Keep-Alive` 은 선택 사항이며, `Connection: Keep-Alive` 헤더가 있는 경우에만 유효

_ex) 헤더 예시_

```http
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- `Keep-Alive` 는 HTTP/1.0 에서 기본 사용 X, `Connection: Keep-Alive` 필요
- 커넥션을 계속 유지하려면 `Connection: Keep-Alive` 요청 헤더를 보내야 함
- 커넥션 유지를 위해서는 엔터티 본문의 길이를 알 수 있어야만 한다
- 프락시와 게이트웨이는 `Connection 헤더`의 규칙을 철저히 지켜야 한다
- `Keep-Alive` 는 `Connection 헤더`를 이해할 수 없는 프락시 서버와 통신해서는 안된다.
- HTTP/1.0 을 따르는 기기로 부터 오는 `Connection 헤더`는 무시해야 한다. HTTP/1.0 을 사용하는 프락시 서버로부터 실수로 전달이 가능
- 응답 전체를 받기 전에 커넥션이 끊어졌다면 클라이언트는 요청을 다시 보낼 준비가 되어 있어야 한다

### 4.5.6 Keep-Alive 와 멈청한(Dumb) 프락시

![img.png](images/04_connection_management_07.png)

- HTTP/1.0 을 사용하는 프락시는 `Connection: Keep-Alive` 를 이해하지 못하고 서버에 전달하고 두 서버는 커넥션을 유지
- 프락시는 서버로 받은 `Connection: Keep-Alive` 이 헤더에 포함된 응답을 클라이언트에 전달하고 클라이언트는 나머지 요청을 전달 시작
- 프락시는 `Connection: Keep-Alive` 를 모르는 상태이므로 이미 종료가 되었어야할 커넥션에서 오는 요청을 무시하고 서버로 전달 X
- 서버는 `Connection: Keep-Alive` 로 인해 만들어진 지속 커넥션 상으로부터 요청을 받지 못하고 서버 타임 아웃을 반환

> 프록시가 HTTP/1.0 이면 지속 커넥션은 불가능 할까요?

### 4.5.7 Proxy-Connection 살펴보기

- 모든 헤더를 무조건 전달하는 문제를 해결하기 위해 `Proxy-Connection` 헤더를 사용하여 해결
- `Proxy-Connection` 을 사용하면 프록시가 HTTP/1.1 을 지원하면 해당 헤더를 `Connection` 헤더로 변환하여 전달하여 문제를 해결

![img.png](images/04_connection_management_08.png)

- 그럼에도 전체 흐름에서 멍청한 프락시가 있는 경우 문제는 동일하게 발생한다

### 4.5.8 HTTP/1.1 의 지속 커넥션

- HTTP/1.1 에서는 `keep-alive` 커넥션을 지원하지 않는 대신, 모든 커넥션을 기본으로 지속 커넥션 처리하도록 설계
- 따라서 요청이 끝나고 커넥션을 종료하고 싶을 경우에는 `Connection: close` 헤더를 명시

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 `Connection: close` 헤더를 포함해 보냈으면, 클라이언트는 해당 커넥션으로 추가 요청 불가
- 클라이언트는 해당 커넥션으로 추가 요청을 보내지 않을 경우 `Connection: close` 를 포함
- 커넥션의 모든 메시지는 자신의 길이 정보를 정확히 가지고 있을 때(Content-Length 값 또는 청크 인코딩 필요)에만 커넥션 지속이 가능
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 별도의 지속 커넥션을 맺고 관리 필요
- HTTP/1.1 기기는 `Connection` 헤더의 값과 상관 없이 언제든지 커넥션을 끊을 수 있음
- HTTP/1.1 어플리케이션은 언제든 커넥션을 복구할 수 있어야 함
- 클라이언트는 최대 2개의 지속 커넥션만을 유지해야 한다

## 4.6 파이프라인 커넥션

- HTTP/1.1 은 지속 커넥션을 통해 첫번째 요청이 서버에 전달 후, 나머지 요청들을 파이프라이닝하여 TCP 커넥션 지연을 단축

![img.png](images/04_connection_management_09.png)

### 파이프라인 커넥션의 제약 사항

- 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전 까지는 파이프라인을 이어서는 안된다
- HTTP 메시지는 순번이 없어서 순서 정렬이 불가능 하므로, HTTP 응답은 요청 순서와 같게 와야한다
- HTTP 클라이언트는 커넥션이 끊어져도, 파이프라인에 요청이 남아있으면 언제든 다시 요청을 보낼 수 있어야 한다
- POST 요청과 같이 비멱등(nonidempotent) 요청은 파이프라인을 통해 보내면 안된다

> 클라리언트에서 비멱등 요청을 연속해서 보내면 안되겠지만, 백엔드 서버에서 멱등성 처리는 어떤 식으로 하면 좋을까요?

## 4.7 커넥션 끊기에 대한 미스터리

### 4.7.1 '마음대로' 커넥션 끊기

- HTTP 는 구조적으로 언제든지 커넥션을 끊을 수 있지만 문제 발생을 야기한다

### 4.7.2 Content-Length 와 Truncation

- 커넥션이 끊어진 이후, 실제 전달 된 `엔터티의 길이`와 `Content-Length` 를 비교하고 서로 다를 경우 서버에 확인 필요
- 프락시는 `Content-Length` 를 캐시하면 안되고, 메시지를 받은 그대로 전달 해야만 문제 방생을 막을 수 있다

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 클라이언트가 트랜잭션을 수행 중에 전송 커넥션이 끊기게 되면 클라이언트는 멱등성이 보장되는 범위에서 커넥션을 다시 맺고 한 번더 요청을 보내야 한다
- 파이프라인 커넥션의 경우 위와 같은 경우에서 더 어려움이 발생
- 여러번 실행되어도 같은 결과를 반환한 멱등성은 GET, HEAD, PUT, DELETE, TRACE, OPTIONS 메서드에서 보장 / POST 메서드는 비보장

### 4.7.4 우하안 커넥션 끊기

#### 전체 끊기와 절반 끊기

- TCP 커넥션은 데이터를 읽거나 쓰기 위한 입력 큐와 출력 큐가 양방향으로 존재
- `close()` 를 호출하면 양방향을 전부 끊으며 `전체 끊기`라고 부른다
- `shutdown()` 을 호출하면 하나를 개별적으로 끊으며 `절반 끊기`라고 부른다

#### TCP 끊기와 리셋 에러

- 단순한 HTTP 커넥션은 `전체 끊기` 만 사용
- 하지만 어플리케이션이 클라이언트 - 서버 - 프락시 등과 파이프라인으로 통신할 때, 예상치 못한 에러는 막기 위해서는 `절반 끊기` 사용 필요
- 입력 채널을 끊게 되면 잘못된 정보가 전달이 가능하며, 서버에 이상 현상을 일으킬 수 있으므로 보통은 출력 채널을 끊는 것이 안전

#### 우아하게 커넥션 끊기

- 최선의 케이슨느 자신의 출력 채널을 끊고 반대편의 기기 출력 채널이 끊기는 것을 기다리는 것. 이렇게 되면 리셋의 위험 없이 커넥션이 완전히 종료
- 단, 상대방이 `절반 끊기`를 구현했다는 보장과 검사를 한다는 보장이 없으므로 상태 검사를 주기적으로 하는 것이 권장
