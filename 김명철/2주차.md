# 2주차

## 1. CRLF (Carriage Return Line Feed)
\r\n = CR(\r) + LF(\n)
HTTP는 반드시 CRLF로 줄 구분:
GET /index.html HTTP/1.1\r\n
Host: example.com\r\n
\r\n
마지막 \r\n\r\n이 헤더 종료를 의미. 없으면 파싱 에러.
## 2. Nginx Upstream/Downstream
용어:
Upstream: Nginx가 요청 전달할 백엔드 서버
Downstream: Nginx에 요청 보내는 클라이언트
설정 예시:
upstream backend {
    least_conn;
    server 192.168.1.10:8080 weight=3;
    server 192.168.1.11:8080;
    server 192.168.1.12:8080 backup;
}

server {
    listen 80;
    location / {
        proxy_pass http://backend;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
## 3. 비완전 URL (Partial URL)
일반 요청 (경로만):
GET /api/users/123 HTTP/1.1
Host: api.example.com
완전 URL (프록시 사용시):
GET http://api.example.com/api/users/123 HTTP/1.1
curl 예시:
### 프록시 통과시
curl -x proxy.com:8080 http://target.com/api/data
## 4. HTTP 응답 버전 = 서버 지원 능력
맞음. 응답의 HTTP 버전 = 서버가 실제 사용한 버전
### 클라이언트 요청
GET / HTTP/1.1

### 서버가 1.0만 지원하면
HTTP/1.0 200 OK  ← 1.1 기능 사용 불가

## 5. Status 100 Continue
용도: 대용량 데이터 전송 전 서버 확인
플로우:
### 1. 클라이언트
POST /upload HTTP/1.1
Content-Length: 104857600
Expect: 100-continue

### 2. 서버 OK
HTTP/1.1 100 Continue

### 3. 본문 전송
[100MB 데이터...]

### 4. 최종 응답
HTTP/1.1 201 Created
거부시:
HTTP/1.1 413 Payload Too Large
### 본문 전송 안함 → 대역폭 절약
Python 예시:
headers = {'Expect': '100-continue'}
requests.post('http://example.com/upload', data=file, headers=headers)
