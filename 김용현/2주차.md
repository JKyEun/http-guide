# 3장. HTTP 메시지

## 3.1 메시지의 흐름

- HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

- HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 인바운드로 이동하는 것 → 메시지가 원 서버로 향하는 것
- 아웃바운드로 이동하는 것 → 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것

### 3.1.2 다운스트림으로 흐르는 메시지

- 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다.

## 3.2 메시지의 각 부분

- HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
- 메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다.
- 시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있거나 아예 없을 수도 있다.

### 3.2.1 메시지 문법

- 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.
- 요청 메시지는 웹 서버에 어떤 동작을 요구한다.
- 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다.
- 메서드
  - 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다.
- 요청 URL
  - 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소다.
- 버전
  - 이 메시지에서 사용 중인 HTTP의 버전이다.
- 상태 코드
  - 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자다.
  - 각 코드의 첫 번째 자릿수는 상태의 일반적인 분류를 나타낸다.
- 사유 구절
  - 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다.

### 3.2.2 시작줄

- 요청 메시지의 시작줄은 무엇을 해야 하는지 말해준다.
- 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

### 3.2.3 헤더

- 헤더분류
  - 일반 헤더 - 요청과 응답 양족에 모두 나타날 수 있음
  - 요청 헤더 - 요청에 대한 부가 정보를 제공
  - 응답 헤더 - 응답에 대한 부가 정보를 제공
  - Entity 헤더 - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
  - 확장 헤더 - 명세에 정의되지 않은 새로운 헤더

### 3.2.4 엔터티 본문

- 엔터티 본문은 HTTP 메시지의 화물이라고 할 수 있다. 그것들은 HTTP가 수송하도록 설계된 것들이다.

## 3.3 메서드

### 3.3.1 안전한 메서드

- HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다.
- GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.

### 3.3.2 GET

- GET은 가장 흔히 쓰이는 메서드다.
- 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

### 3.3.3 HEAD

- HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.
- 엔터티 본문은 결코 반환되지 않는다.

### 3.3.4 PUT

- GET 메서드가 서버로부터 문서를 읽어 들이는데 반해 PUT 메서드는 서버에 문서를 쓴다.
- PUT 메서드의 의미는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

### 3.3.5 POST

- POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다.

### 3.3.6 TRACE

- 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다. 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.
- TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

### 3.3.7 OPTIONS

- OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.

### 3.3.8 DELETE

- DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.

### 3.3.9 확장 메서드

- HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.

## 3.4 상태 코드

- HTTP 상태 코드는 크게 다섯 가지로 나뉜다.
- 상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

### 3.4.1 100-199: 정보성 상태 코드

- 정보성 상태 코드는 HTTP/1.1에서 도입되었다.

### 3.4.2 200-299: 성공 상태 코드

- 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.

### 3.4.3 300-399: 리다이렉션 상태 코드

- 리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.

### 3.4.4 400-499: 클라이언트 에러 상태 코드

- 잘못 구성된 요청 메시지 같은 것이 있을 수 있으며, 가장 흔한 것은 존재하지 않는 URL에 대한 요청이다.

### 3.4.5 500-599: 서버 에러 상태 코드

- 때때로, 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다. 이것은 클라이언트가 서버의 제한에 걸린 것일 수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.

## 3.5 헤더

- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.

### 3.5.1 일반 헤더

- 일반 헤더는 클라이언트와 서버 양쪽 모두가 사용한다.
- 이들은 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.

### 3.5.2 요청 헤더

- 이름에서 드러나는 것과 같이 요청 헤더는 요청 메시지를 위한 헤더다.
- 그들은 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.

### 3.5.3 응답 헤더

- 응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.

# 4장. 커넥션 관리

## 4.1 TCP 커넥션

- 전세계 모든 HTTP 통신은, 지구상의 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.
- 세계 어디서든 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있다.
- 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- TCP 커넥션은 인터넷을 안정적으로 연결해 준다.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

- TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터를 전송한다.

### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다.
- TCP는 포트 번호를 통해서 이런 여러 개의 커넥션을 유지한다.

### 4.1.4 TCP 소켓 프로그래밍

- 소켓 API를 사용하면, TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

## 4.2 TCP의 성능에 대한 고려

- HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

### 4.2.1 HTTP 트랜잭션 지연

- 이런 TCP 네트워크 지연은 하드웨어의 성능, 네트워크와 서버의 전송 속도, 요청과 응답 메시지의 크기, 클라이언트와 서버 간의 거리에 따라 크게 달라진다.
- 또한 TCP 프로토콜의 기술적인 복잡성도 지연에 큰 영향을 끼친다.

### 4.2.2 성능 관련 중요 요소

- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글 알고리즘
- TCP의 편승 확인응답을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 어떤 데이터를 전송하든 새로운 TCP 커넥션을 열 때면, TCP 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 IP 패킷을 교환한다.
- 작은 크기의 데이터 전송에 커넥션이 사용된다면 이런 패킷 교환은 HTTP 성능을 크게 저하시킬 수 있다.

### 4.2.4 확인응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에 TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가진다.

### 4.2.5 TCP 느린 시작

- TCP의 데이터 전송 속도는 TCP 커넥션이 만들어진 지 얼마나 지났는지에 따라 달라질 수 있다.
- TCP 커넥션은 시간이 지나면서 자체적으로 튜닝되어서 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여나가는데 이렇게 조율하는 것을 TCP 느린 시작이라고 부르며 이는 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 쓰인다.

### 4.2.6 네이글 알고리즘과 TCP_NODELAY

- 네이글 알고리즘은 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다.

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP 메시지는 클라이언트에서 서버까지 중개 서버들을 하나하나 거치면서 전달된다.
- 어떤 경우에는, 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있다.
- HTTP Connection 헤더 필드는 커넥션 토큰을 쉽표로 구분하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않는다.

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- HTTP 커넥션의 성능을 향상 시킬 수 있는 여러 최신 기술이 있다.
  - 병렬 커넥션
  - 지속 커넥션
  - 파이프라인 커넥션
  - 다중 커넥션

## 4.4 병렬 커넥션

- HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.

- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.

### 4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있다.

## 4.5 지속 커넥션

- HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다. 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부른다.

### 4.5.1 지속 커넥션 vs 병렬 커넥션

### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

- 네개의 커넥션을 생성하여 처리하는 방식에 비해 하나의 지속 커넥션으로만 처리하는 방식은 커넥션을 맺고 끊는 데 필요한 작업이 없어서 시간이 단축된다.
-
